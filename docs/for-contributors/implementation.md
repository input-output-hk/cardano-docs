# Implementation

This section should serve as a starting point for developers who wish to
contribute to the original client, as well as those who wish to undertake making
their own client for Cardano SL. Nonetheless, this section covers the
original client to great extent, assuming that it's an initial
reference client for some time.

## High-level overview

A Cardano SL node is a blockchain node. When ran, it finds other
nodes (via [DHT](http://ast-deim.urv.cat/cpairot/dhts.html)) and then starts
performing blockchain-related procedures.

Time in Cardano SL is divided into _epochs_. Every epoch is divided
into _slots_. Epochs and slots are numbered. Therefore, slot `(3,5)`
is read as "fifth slot of the third epoch" (0th slot and 0th epoch are also possible).

The values for Cardano SL are:

- Slot duration: 15 seconds
- Security parameter *k*: 2

Please refer to the [last section](#constants) of this article to see all the
consants and their values.

In other words, **a slot lasts 15 seconds**, and an epoch has `6×k=12` slots
in it, thus it lasts **3 minutes**.

On each slot, one, *and only one*, of the nodes generates a block to be added
to the blockchain. During the epoch, nodes send each other MPC
messages to come to the consensus as to who would be allowed to generate blocks
in the next epoch. These messages (along with transactions) are included
into blocks.

The more currency (or "stake") an address holds, the more likely it to
be chosen to generate a block. Please refer to [the pertinent
section](/cardano/proof-of-stake/) for more details.

In short: Send messages, receive messages/transactions/etc, form a
block (if you're the selected stakeholder), repeat.

## Business logic

### Listeners

Listeners handle incoming messages and respond to them. Various
supplemental listeners will not be covered, instead focusing on the main ones:

- Block listeners:
    - `handleBlock`: Handles an incoming block. Takes transactions from it,
       sends the block header to other nodes, etc.
    - `handleBlockHeader`: Handles an incoming block header. Decides whether the block is needed or not; if it is then request the block.
    - `handleBlockRequest`: Handles an incoming block request. If block is in possession, sends it to the other node.

- Transaction listeners:
    - `handleTx`: Processes a single transaction.
    - `handleTxs`: Processes multiple transactions and relays the ones that have
       validated successfully to other nodes.

- SSC Listeners:
    - `handleSsc`: Handles consensus-related messages and responds to them.

### Workers

A Worker is an action repeating with some interval. The workers of importance are:

- `onNewSlotWorker`: Runs at the beginning of each slot. Does some cleanup,
   etc, and then it runs `sscOnNewSlot` and `blkOnNewSlot`. This
   worker also creates  a _genesis block_ if it's the beginning of
   the epoch. There are two kinds of blocks – "genesis blocks" and
   "main blocks". Main blocks are stored in the blockchain, genesis blocks are
   generated by each node internally between epochs. Gnesis blocks aren't
   announced to other nodes. For convenience, however, a node may request
   a genesis block from someone else if this node was offline for some time
   and needs to catch up with the blockchain.
    - `blkOnNewSlot`: Creates a new block (when it's the node's turn to create
   a new block) and announces it to other nodes.
    - `sscOnNewSlot`: Sends a message to other nodes. The actual consensus
   algorithm and the nature of sent messages will be discussed later.

- `blocksTransmitter`: Runs two times per slot. Announces the header of the
  latest block.
- `txsTransmitter`: Runs once per slot. Announces the local set of transactions.
- `sscTransmitter`: Retransmits SSC messages. To find out how often
  this worker runs, see `mpcRelayInterval` constant in the original client.

## Proof of Stake

At the heart or Cardano SL sits the Oruboros Proof of Stake protocol, as
described in [the whitepaper](https://eprint.iacr.org/2016/889) of the same
name.

### Static state

_Pending_

### Dynamic state

_Pending_

#### Follow the Satoshi

_Pending_

#### Obtaining the same seed

_Pending_

## Blocks

### `MainBlockchain`

_Pending_

### `GenesisBlockchain`

_Pending_

## Forks

Generally, one chain (the _main chain_) is maintained by a node, but eventually
alternative chains may arise. Recall that only blocks `k` and more slots deep
are considered stable. This way if a block which is neither a
part nor a continuation of our blockchain is received, we first check if its complexity
is bigger than ours (the complexity is the length of the chain), we start
subsequently request previous blocks from the node that provided alternative chain
header. If we come deeper than `k` slots ago, the alternative chain gets
rejected. Otherwise, once we get to the block existing in our chain, the
alternative chain is getting added to storage. From the standpoint of
state, we store and "maintain" all the alternative chains that are viable.
If it appears that an alternative chain is longer than the main chain, they
are swapped, making the alternative chain the new main chain.

## Supplemental parts

### SSC

SSC stands for Shared Seed Calculation.

_Pending: what to talk about here that is general enough for the original
client and for alternative clients?_

### Crypto

_Pending: what to talk about here that is general enough for the original
client and for alternative clients?_

### Storage

_Pending: what to talk about here that is general enough for the original
client and for alternative clients? Storage is RocksDB for original client,
but alternative clients may want to implement with different engine. Do we
want to simply mention RocksDB and leave it as a recommendation, or expand
further?_

### Slotting

The consensus scheme used relies on correct slotting. More specifically, it
relies on the assumption that nodes in the system have access to the current
time (small deviations are acceptable), which is then used to figure
out when any particular slot begins and ends, and do particular
actions in that slot.

System start time is a timestamp of the (0,0) slot (i.e. the 0th slot of
the 0th epoch).

_Pending: Is the timelord-timeslave scheme still relevant?_

## P2P Network

### Peer discovery

For peer discovery  Kademlia DHT is used. It’s a general solution for distributed
hash tables, based on [whitepaper by Petar Maymounkov and David Mazières,
2002.](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)

However, it's not used as a table, only its peer discovery mechanism.

In short, each node in the Kademlia network is provided a `160`-bit id which is
randomly generated. Distance between nodes is defined by `XOR` metric. Network
is organized in such way that node knows no more than `K` (`K=7` in  the
original client implementation) nodes for each relative distance
range: `2^i < d <= 2^(i+1)`.

### Messaging

Kademlia already provides the notion of nodes that are known. Which
can be simply called _neighbors_. To send message to all nodes in
network, you can send it to neighbors, they resend it to their
neighbors, and so on. But sometimes we may need to not propagate
messages across all network, but instead send it to neighbors
only. Hence we have three types of sending:

- Send to node
- Send to neighbors
- Send to network

#### Message types

To handle this three kind of message headers are used, there's two message types:

- Simple: _Pending: Describes how a Simple message is implemented_
- Broadcast:  _Pending: Describes how a Broadcast message is implemented_

Broadcast messages are getting resent to neighbors right after retrieval (before
handling). Also, they are being checked against LRU cache and messages
that are already received once get ignored.

## Constants

The following list of constants are used in the original client. Their values
have been discussed with the original authors of of the protocol as well as
independent security auditors, so their reuse is strongly suggested for
alternative clients.

| Constant name                 | Value         | Description                  |
|-------------------------------|---------------|------------------------------|
| **Protocol constants**        |               |                              |
| k                             |             2 | Security parameter           |
| slotDurationSec               |            10 | Duration of slots in seconds |
| networkDiameter               |             3 | _Pending_                    |
| neighboursSendThreshold       |             4 | _Pending_                    |
| genesisN                      |            20 | _Pending_                    |
| maxLocalTxs                   |         10000 | _Pending_                    |
| defaultPeers                  |            [] | _Pending_                    |
| sysTimeBroadcastSlots         |             6 | _Pending_                    |
| mpcSendInterval               |            12 | Must be less than `k * slotDuration - networkDiameter` |
| mdNoBlocksSlotThreshold       |            10 | _Pending_                    |
| mdNoCommitmentsEpochThreshold |             3 | _Pending_                    |
| vssMaxTTL                     |           100 | In Epochs                    |
| protocolMagic                 |             0 | _Pending_                    |
| enchancedMessageBroadcast     |             2 | _Pending_                    |
| delegationThreshold           |         0.001 | 1% of the stake              |
| **Update system constants**   |               |                              |
| updateServers                 |            [] | List of IPs                  |
| maxBlockProxySKs              |         10000 | _Pending_                    |
| updateProposalThreshold       |           0.1 | 10% of the total stake       |
| updateVoteThreshold           |         0.001 | 0.1% of the total stake      |
| updateImplicitApproval        |         40000 | In Slots                     |
