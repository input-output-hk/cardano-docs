{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction to Cardano SL\n\n\n\n\nCardano SL (or Cardano Settlement Layer) is a cryptographic\ncurrency designed and developed by \nIOHK\n. You can\nthink of this product as of Bitcoin reimagined with a freedom to fix\ndesign flaws of Bitcoin. For those\nwho don't know what Bitcoin is, in the \nnext\nsection\n we'll talk a little\nbit about what a cryptocurrency is and why do cryptocurrencies matter.\nIf you have basic understanding of Bitcoin, you may\n\nskip\n the next\nsection. If you're eager to start working with Cardano SL, refer to\n\nInstallation Guide\n and \nWallet Operation Guide\n to get started.\n\n\nCryptocurrency Basics\n\n\nBefore giving a definition of a cryptocurrency, let's first talk about\nwhy do we care about digital currencies in general and cryptographic\ncurrencies in particular.\n\n\nWhy Do We Care?\n\n\nSpeed\n\n\nAs opposed to conventional (also known as fiat), centrally banked\ncurrencies such as Yen or American Dollar, digital currencies don't\nrequire a banking system to move value. With this restriction lifted,\nwork with digital currencies is much faster than work with banking,\nespecially on the global scale. The transfer of sending 10USD from\nOsaka to Denver no longer takes days when digital currency is\nused. All transactions are done rapidly, no matter the distance. The\ntransfer also follows the same understandable rules within a\npredictable amount of time, ensuring speed and reliability.\n\n\nYou Own Your Money\n\n\nAll that a commercial bank account owner is given is a promise of\nbeing paid a certain amount of money within a reasonable amount of\ntime after receiving a payout request.  Of course, banking systems\nalso have limits to any volume of value being moved, rendering an\nindividual unable to withdraw or transfer large amounts quickly. In\ncase of cryptocurrencies, the person who holds a\nspecial kind of information, called \na secret key\n can spend the money\nat will. No other entity has a power to manipulate value that a user\nhas.\n\n\nPseudonymity\n\n\nOne can have as many cryptocurrency addresses as they wish, receiving\nand spending money from different addresses as per their purpose. A\nmerchant running an E-Commerce shop can have a set of addresses to\nreceive money and issue refunds and a personal \"wallet\" for their own\nneeds. All of this is controlled from one interface and there is no need\nto log in to several payment platforms, which in turn makes the\nprocess very time efficient.\n\n\nSecurity\n\n\nYour money is as secure as the \nsecret key\n that allows spending it.\nThat means that storing your secret key in a safe on a laptop\ndisconnected from the Internet is equivalent of having banknotes in a\npassword-protected lock-box in a safe. Absolutely nobody can steal this\nmoney even by carrying out a successful cyber-attack.\n\n\nExtensibility\n\n\nUsing an approach known as \nside chains\n, general-purpose\ncryptocurrencies (such as Cardano SL or Bitcoin) can enable\ndomain-specific cryptocurrencies, such as Ethereum Classic. This way,\nany innovation developed via domain-specific\ncryptocurrency, can have participants who hold value in a\ngeneral-purpose cryptocurrency. Examples of such\napplications are identity management, gaming and gambling, verifiable\ncomputations.\n\n\nWhat is a Cryptocurrency?\n\n\nCryptocurrency is a form of digital currency that uses cryptography to\nmanipulate value. Cryptography provides a way to generate\nproof of genuine authenticity of any kind of information. This is called\n\ndigital signing\n. In cryptocurrencies we generate a ledger (a database\nwhich answers a question \"which address has how much money\") by signing\nand sending transactions into the network and receiving blocks of\nconfirmed transactions. Cryptocurrencies are normally decentralized,\nmeaning that many people from all over the globe participate in\nledger generation by running cryptocurrency nodes. Obviously, a\nconsensus about the state of the ledger has to be achieved. Two most\nsignificant approaches for achieving such consensus are discussed in the\nnext section.\n\n\nWhat Makes Cardano SL Special?\n\n\nThere are a lot of similarities between Bitcoin and Cardano\nSL, but also there are quite some differences between those two\ncryptocurrencies.The most significant difference is that Bitcoin is a\nProof of Work type cryptocurrency, while Cardano SL makes use of a\nProof of Stake approach to reach consensus. This empowers honesty and\nlongevity of the participants.\n\n\nPurpose of a Consensus Algorithm\n\n\nConsensus algorithms are used to produce new transaction blocks,\nresulting in updated state of the ledger. Whenever someone publishes\na block of transactions, they (or rather, their node that runs the\ncryptocurrency protocol) have to attach a proof that they have merited\nit. Below two types of such proofs are discussed.\n\n\nProof of Work and Mining\n\n\nProof of Work is the most common consensus algorithm type for\ncryptocurrencies. It originated in Bitcoin and is the reason why this\ncurrency works well. To generate Proof of Work, a computer has to\nsolve a challenge. The challenge is a computationally heavy problem\nwhich is hard to solve, but the solution is easy to verify. When a\ncomputer on a Proof of Work-based network finds a solution, it publishes\nit along with the transactions that the computer observed while\ncracking the problem. The owner of this computer collects the transaction\nfees and reward for generating a block. The entire process is called\n\nmining\n. Mining is very energy-consuming and it's increase is\nanalogous to competitiveness.\n\n\nProof of Stake and Minting\n\n\nProof of Stake is a novel approach to block generation. IOHK scientists,\nlead by \nProf. Aggelos Kiayias\n\nhave designed the first provably secure proof of stake algorithm called\nOuroboros. Ouroboros lies at the heart of Cardano SL. Research team has\npublished a\n\nwhitepaper\n\nwhich is a worthy read for anyone with background in cryptocurrency\ntheory. The core of Proof of Stake is that instead of wasting\nelectricity on cracking computationally heavy problems, a node is\nselected to mint a new block, with a probability that is proportional\nto the amount of coins a particular node has. A node that attempts to\ngenerate a block is called \"a stakeholder\". You can read more about this process in \nProof\nof Stake in Cardano SL\n.\n\n\nBeyond Settlement Layer\n\n\nCardano SL is a \"Layer\" for a reason. It's the first component of\nthe Cardano Platform. Eventually it will be expanded with a Control Layer,\nserving as a trusted computation framework to evaluate special\nkind of proofs to ensure that a certain computation was carried out\ncorrectly. In gaming and gambling, such systems are  useful for\nverifying the honesty of random number generation and game\noutcomes. Accompanied with \nside chains\n it will allow to accomplish\nsuch tasks as provably fair distribution of winnings in games. The\napplication of Control Layer lies well beyond gaming and gambling\napplications. Identity management, credit system and more will be a\npart of Cardano Platform. We are also aiming to evolve Cardano SL wallet\nprogram called \nDaedalus\n into a universal cryptocurrency wallet\nwith automated cryptocurrency trading and cryptocurrency-to-fiat\ntransactions.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction-to-cardano-sl", 
            "text": "Cardano SL (or Cardano Settlement Layer) is a cryptographic\ncurrency designed and developed by  IOHK . You can\nthink of this product as of Bitcoin reimagined with a freedom to fix\ndesign flaws of Bitcoin. For those\nwho don't know what Bitcoin is, in the  next\nsection  we'll talk a little\nbit about what a cryptocurrency is and why do cryptocurrencies matter.\nIf you have basic understanding of Bitcoin, you may skip  the next\nsection. If you're eager to start working with Cardano SL, refer to Installation Guide  and  Wallet Operation Guide  to get started.", 
            "title": "Introduction to Cardano SL"
        }, 
        {
            "location": "/#cryptocurrency-basics", 
            "text": "Before giving a definition of a cryptocurrency, let's first talk about\nwhy do we care about digital currencies in general and cryptographic\ncurrencies in particular.", 
            "title": "Cryptocurrency Basics"
        }, 
        {
            "location": "/#why-do-we-care", 
            "text": "", 
            "title": "Why Do We Care?"
        }, 
        {
            "location": "/#speed", 
            "text": "As opposed to conventional (also known as fiat), centrally banked\ncurrencies such as Yen or American Dollar, digital currencies don't\nrequire a banking system to move value. With this restriction lifted,\nwork with digital currencies is much faster than work with banking,\nespecially on the global scale. The transfer of sending 10USD from\nOsaka to Denver no longer takes days when digital currency is\nused. All transactions are done rapidly, no matter the distance. The\ntransfer also follows the same understandable rules within a\npredictable amount of time, ensuring speed and reliability.", 
            "title": "Speed"
        }, 
        {
            "location": "/#you-own-your-money", 
            "text": "All that a commercial bank account owner is given is a promise of\nbeing paid a certain amount of money within a reasonable amount of\ntime after receiving a payout request.  Of course, banking systems\nalso have limits to any volume of value being moved, rendering an\nindividual unable to withdraw or transfer large amounts quickly. In\ncase of cryptocurrencies, the person who holds a\nspecial kind of information, called  a secret key  can spend the money\nat will. No other entity has a power to manipulate value that a user\nhas.", 
            "title": "You Own Your Money"
        }, 
        {
            "location": "/#pseudonymity", 
            "text": "One can have as many cryptocurrency addresses as they wish, receiving\nand spending money from different addresses as per their purpose. A\nmerchant running an E-Commerce shop can have a set of addresses to\nreceive money and issue refunds and a personal \"wallet\" for their own\nneeds. All of this is controlled from one interface and there is no need\nto log in to several payment platforms, which in turn makes the\nprocess very time efficient.", 
            "title": "Pseudonymity"
        }, 
        {
            "location": "/#security", 
            "text": "Your money is as secure as the  secret key  that allows spending it.\nThat means that storing your secret key in a safe on a laptop\ndisconnected from the Internet is equivalent of having banknotes in a\npassword-protected lock-box in a safe. Absolutely nobody can steal this\nmoney even by carrying out a successful cyber-attack.", 
            "title": "Security"
        }, 
        {
            "location": "/#extensibility", 
            "text": "Using an approach known as  side chains , general-purpose\ncryptocurrencies (such as Cardano SL or Bitcoin) can enable\ndomain-specific cryptocurrencies, such as Ethereum Classic. This way,\nany innovation developed via domain-specific\ncryptocurrency, can have participants who hold value in a\ngeneral-purpose cryptocurrency. Examples of such\napplications are identity management, gaming and gambling, verifiable\ncomputations.", 
            "title": "Extensibility"
        }, 
        {
            "location": "/#what-is-a-cryptocurrency", 
            "text": "Cryptocurrency is a form of digital currency that uses cryptography to\nmanipulate value. Cryptography provides a way to generate\nproof of genuine authenticity of any kind of information. This is called digital signing . In cryptocurrencies we generate a ledger (a database\nwhich answers a question \"which address has how much money\") by signing\nand sending transactions into the network and receiving blocks of\nconfirmed transactions. Cryptocurrencies are normally decentralized,\nmeaning that many people from all over the globe participate in\nledger generation by running cryptocurrency nodes. Obviously, a\nconsensus about the state of the ledger has to be achieved. Two most\nsignificant approaches for achieving such consensus are discussed in the\nnext section.", 
            "title": "What is a Cryptocurrency?"
        }, 
        {
            "location": "/#what-makes-cardano-sl-special", 
            "text": "There are a lot of similarities between Bitcoin and Cardano\nSL, but also there are quite some differences between those two\ncryptocurrencies.The most significant difference is that Bitcoin is a\nProof of Work type cryptocurrency, while Cardano SL makes use of a\nProof of Stake approach to reach consensus. This empowers honesty and\nlongevity of the participants.", 
            "title": "What Makes Cardano SL Special?"
        }, 
        {
            "location": "/#purpose-of-a-consensus-algorithm", 
            "text": "Consensus algorithms are used to produce new transaction blocks,\nresulting in updated state of the ledger. Whenever someone publishes\na block of transactions, they (or rather, their node that runs the\ncryptocurrency protocol) have to attach a proof that they have merited\nit. Below two types of such proofs are discussed.", 
            "title": "Purpose of a Consensus Algorithm"
        }, 
        {
            "location": "/#proof-of-work-and-mining", 
            "text": "Proof of Work is the most common consensus algorithm type for\ncryptocurrencies. It originated in Bitcoin and is the reason why this\ncurrency works well. To generate Proof of Work, a computer has to\nsolve a challenge. The challenge is a computationally heavy problem\nwhich is hard to solve, but the solution is easy to verify. When a\ncomputer on a Proof of Work-based network finds a solution, it publishes\nit along with the transactions that the computer observed while\ncracking the problem. The owner of this computer collects the transaction\nfees and reward for generating a block. The entire process is called mining . Mining is very energy-consuming and it's increase is\nanalogous to competitiveness.", 
            "title": "Proof of Work and Mining"
        }, 
        {
            "location": "/#proof-of-stake-and-minting", 
            "text": "Proof of Stake is a novel approach to block generation. IOHK scientists,\nlead by  Prof. Aggelos Kiayias \nhave designed the first provably secure proof of stake algorithm called\nOuroboros. Ouroboros lies at the heart of Cardano SL. Research team has\npublished a whitepaper \nwhich is a worthy read for anyone with background in cryptocurrency\ntheory. The core of Proof of Stake is that instead of wasting\nelectricity on cracking computationally heavy problems, a node is\nselected to mint a new block, with a probability that is proportional\nto the amount of coins a particular node has. A node that attempts to\ngenerate a block is called \"a stakeholder\". You can read more about this process in  Proof\nof Stake in Cardano SL .", 
            "title": "Proof of Stake and Minting"
        }, 
        {
            "location": "/#beyond-settlement-layer", 
            "text": "Cardano SL is a \"Layer\" for a reason. It's the first component of\nthe Cardano Platform. Eventually it will be expanded with a Control Layer,\nserving as a trusted computation framework to evaluate special\nkind of proofs to ensure that a certain computation was carried out\ncorrectly. In gaming and gambling, such systems are  useful for\nverifying the honesty of random number generation and game\noutcomes. Accompanied with  side chains  it will allow to accomplish\nsuch tasks as provably fair distribution of winnings in games. The\napplication of Control Layer lies well beyond gaming and gambling\napplications. Identity management, credit system and more will be a\npart of Cardano Platform. We are also aiming to evolve Cardano SL wallet\nprogram called  Daedalus  into a universal cryptocurrency wallet\nwith automated cryptocurrency trading and cryptocurrency-to-fiat\ntransactions.", 
            "title": "Beyond Settlement Layer"
        }, 
        {
            "location": "/installation/", 
            "text": "Get Cardano SL\n\n\n\n\nWindows\n\n\nmacOS\n\n\n\n\nLinux installer is going to be released soon. For now, to get Cardano\nSL on Linux, please refer to the \nBuilding From\nSource\n section.\n\n\nRunning a Node\n\n\nIn January 2017 the network enters \ntestnet era\n. A\ntest network is released and anyone interested in using Cardano SL can\nclaim Ada by requesting it from the Cardano SL Testnet Faucet.\nDuring this period of time we aim to excessively test all the protocol\ncapabilities, eliminating possible implementation problems that can lead\nto the network instability. Testnet will get reset once during this\ntime.\n\n\nSome time later in 2017 the system will go live with initial ninety days\nof \nbootstrapping era\n. As the network will enter \nrewarding\nera\n.  Then it will be advisable for stakeholders\nwith a considerable amount of \nstake\n to\nparticipate in running the protocol by keeping the node online with port\n\n8777\n open. We plan to release a one-click solution for running a node\nin the cloud, which will allow you to participate in running the\nprotocol with zero-maintenance.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#get-cardano-sl", 
            "text": "Windows  macOS   Linux installer is going to be released soon. For now, to get Cardano\nSL on Linux, please refer to the  Building From\nSource  section.", 
            "title": "Get Cardano SL"
        }, 
        {
            "location": "/installation/#running-a-node", 
            "text": "In January 2017 the network enters  testnet era . A\ntest network is released and anyone interested in using Cardano SL can\nclaim Ada by requesting it from the Cardano SL Testnet Faucet.\nDuring this period of time we aim to excessively test all the protocol\ncapabilities, eliminating possible implementation problems that can lead\nto the network instability. Testnet will get reset once during this\ntime.  Some time later in 2017 the system will go live with initial ninety days\nof  bootstrapping era . As the network will enter  rewarding\nera .  Then it will be advisable for stakeholders\nwith a considerable amount of  stake  to\nparticipate in running the protocol by keeping the node online with port 8777  open. We plan to release a one-click solution for running a node\nin the cloud, which will allow you to participate in running the\nprotocol with zero-maintenance.", 
            "title": "Running a Node"
        }, 
        {
            "location": "/getting-started/ui/", 
            "text": "Navigating in Daedalus User Interface\n\n\nDaedalus, the wallet of Cardano SL offers a multitude of functions, that\nare easy and intuitive to use. Menu animations flow well and have a\nzero-distraction mode. UI is minimalistic, color scheme is neutral. The\nstructure is concise and easy to follow. We've built Daedalus for your\nconvenience, prioritizing user experience and intuitive design. Current\nfeature set is minimalistic, most importantly it consists of options to\n\n\n\n\nCheck your balance\n\n\nMake transactions\n\n\nCreate custom \"wallets\" tailored for your needs\n\n\nSet up identity\n\n\n\n\nMany more features are coming soon, so stay tuned for the update\nchangelogs and changes to this documentation!\n\n\nLayout\n\n\n\n\nThe general layout of the UI gives room to split into left, middle and\nright section, excluding the header, footer and margins used for\ncomposition. When referred to in the document, the left side refers to\n\nthe menu\n, middle refers to \nmain contents\n of page in question, right\nholds \ninformation and extra options\n.\n\n\nWallet\n\n\n\n\nDenoted with an icon that represents a physical wallet.  Highlighted\nupon hovering. Each sub-menu contains information about Ada balance\ncorresponding to each wallet; an option to \nsend\n and \nreceive\n money\n(highlighted upon hovering). Each wallet shows chronologically ordered\ntransaction history.\n\n\nSend Money\n\n\n\n\nTo send money you should click on \u201cSend Money\u201d button and fill in dialog\nconsisting of the following inputs:\n\n\n\n\nReceiver (Ada address)\n\n\nAmount (In Ada tokens)\n\n\nDescription (Optional)\n\n\nSend button\n\n\n\n\nReceive Money\n\n\nIf you want to receive money from someone and want to tell them your\naddress, click \u201cReceive Money\u201d button. In the midsection your address\nwill be displayed, as well as its QR encoding.\n\n\nWe're working on generating requests for specific amounts of Ada.\nBelow will be a field to do so (inactive at the moment).\n\n\nUpon clicking either sending or receiving, the menu will stay the same,\nshowing wallet balance.\n\n\nWhen you click on the hamburger button, a sub-menu is expanded, listing\nyour wallets and providing you with an option to add a new wallet.\n\n\nSettings\n\n\n\n\nDenoted with a double toggle icon on the far left side of the page.\nUpon clicking, a profile editing page with following fields\nopens:\n\n\n\n\nName\n\n\nE-mail\n\n\nProfile picture upload\n\n\nPhone number\n\n\nPassword\n\n\nLanguage\n\n\n\n\nYou can upload a profile picture by\ndragging and dropping a file or clicking to upload.\n\n\nPassword field shows when the password was last updated.\n\n\nOn the right side more groups of settings can be seen (aside from the\nProfile that was already discussed previously):\n\n\n\n\nSecurity\n\n\nIdentity and Verification\n\n\nDisplay\n\n\nPrivacy\n\n\nTerms of Use\n\n\n\n\nStaking\n\n\n\n\nStaking information, delegation and Instant Buy options are something\nwe're considering to add in the nearest future. For now, the process of\nstaking is carried out autmatically on background.", 
            "title": "Navigating in the User Interface"
        }, 
        {
            "location": "/getting-started/ui/#navigating-in-daedalus-user-interface", 
            "text": "Daedalus, the wallet of Cardano SL offers a multitude of functions, that\nare easy and intuitive to use. Menu animations flow well and have a\nzero-distraction mode. UI is minimalistic, color scheme is neutral. The\nstructure is concise and easy to follow. We've built Daedalus for your\nconvenience, prioritizing user experience and intuitive design. Current\nfeature set is minimalistic, most importantly it consists of options to   Check your balance  Make transactions  Create custom \"wallets\" tailored for your needs  Set up identity   Many more features are coming soon, so stay tuned for the update\nchangelogs and changes to this documentation!", 
            "title": "Navigating in Daedalus User Interface"
        }, 
        {
            "location": "/getting-started/ui/#layout", 
            "text": "The general layout of the UI gives room to split into left, middle and\nright section, excluding the header, footer and margins used for\ncomposition. When referred to in the document, the left side refers to the menu , middle refers to  main contents  of page in question, right\nholds  information and extra options .", 
            "title": "Layout"
        }, 
        {
            "location": "/getting-started/ui/#wallet", 
            "text": "Denoted with an icon that represents a physical wallet.  Highlighted\nupon hovering. Each sub-menu contains information about Ada balance\ncorresponding to each wallet; an option to  send  and  receive  money\n(highlighted upon hovering). Each wallet shows chronologically ordered\ntransaction history.", 
            "title": "Wallet"
        }, 
        {
            "location": "/getting-started/ui/#send-money", 
            "text": "To send money you should click on \u201cSend Money\u201d button and fill in dialog\nconsisting of the following inputs:   Receiver (Ada address)  Amount (In Ada tokens)  Description (Optional)  Send button", 
            "title": "Send Money"
        }, 
        {
            "location": "/getting-started/ui/#receive-money", 
            "text": "If you want to receive money from someone and want to tell them your\naddress, click \u201cReceive Money\u201d button. In the midsection your address\nwill be displayed, as well as its QR encoding.  We're working on generating requests for specific amounts of Ada.\nBelow will be a field to do so (inactive at the moment).  Upon clicking either sending or receiving, the menu will stay the same,\nshowing wallet balance.  When you click on the hamburger button, a sub-menu is expanded, listing\nyour wallets and providing you with an option to add a new wallet.", 
            "title": "Receive Money"
        }, 
        {
            "location": "/getting-started/ui/#settings", 
            "text": "Denoted with a double toggle icon on the far left side of the page.\nUpon clicking, a profile editing page with following fields\nopens:   Name  E-mail  Profile picture upload  Phone number  Password  Language   You can upload a profile picture by\ndragging and dropping a file or clicking to upload.  Password field shows when the password was last updated.  On the right side more groups of settings can be seen (aside from the\nProfile that was already discussed previously):   Security  Identity and Verification  Display  Privacy  Terms of Use", 
            "title": "Settings"
        }, 
        {
            "location": "/getting-started/ui/#staking", 
            "text": "Staking information, delegation and Instant Buy options are something\nwe're considering to add in the nearest future. For now, the process of\nstaking is carried out autmatically on background.", 
            "title": "Staking"
        }, 
        {
            "location": "/getting-started/first-transaction/", 
            "text": "Your First Transaction\n\n\nWhat's the point of a cryptocurrency if we can't send a transaction with\nit? In this section we will explore step by step how you can create a\nwallet and transfer some Ada to yourself.\n\n\nAfter you redeemed your Ada voucher, all your Ada is in a wallet called\n\u201cRedemption Wallet\u201d. Let's create a wallet called \u201cPersonal Wallet\u201d and\ntransfer some Ada from \u201cRedemption Wallet\u201d to the \u201cPersonal Wallet\u201d.\n\n\nCreate Personal Wallet\n\n\nTo create new wallet, follow this illustrated guide:\n\n\nPending\n\n\nNow that the wallet is created, select it, go to Receive tab and follow\nthe instructions below to copy the address of this wallet.\n\n\nPending\n\n\nMake a Transaction to Your Personal Wallet\n\n\nNow that you have target address in the clipboard, follow the\ninstructions below to create a transaction sending some Ada from\n\u201dRedemption Wallet\u201c to the newly created \u201cPersonal Wallet\u201d. Paste the\naddress of your wallet in the field marked with (!).\n\n\nPending", 
            "title": "Your first transaction"
        }, 
        {
            "location": "/getting-started/first-transaction/#your-first-transaction", 
            "text": "What's the point of a cryptocurrency if we can't send a transaction with\nit? In this section we will explore step by step how you can create a\nwallet and transfer some Ada to yourself.  After you redeemed your Ada voucher, all your Ada is in a wallet called\n\u201cRedemption Wallet\u201d. Let's create a wallet called \u201cPersonal Wallet\u201d and\ntransfer some Ada from \u201cRedemption Wallet\u201d to the \u201cPersonal Wallet\u201d.", 
            "title": "Your First Transaction"
        }, 
        {
            "location": "/getting-started/first-transaction/#create-personal-wallet", 
            "text": "To create new wallet, follow this illustrated guide:  Pending  Now that the wallet is created, select it, go to Receive tab and follow\nthe instructions below to copy the address of this wallet.  Pending", 
            "title": "Create Personal Wallet"
        }, 
        {
            "location": "/getting-started/first-transaction/#make-a-transaction-to-your-personal-wallet", 
            "text": "Now that you have target address in the clipboard, follow the\ninstructions below to create a transaction sending some Ada from\n\u201dRedemption Wallet\u201c to the newly created \u201cPersonal Wallet\u201d. Paste the\naddress of your wallet in the field marked with (!).  Pending", 
            "title": "Make a Transaction to Your Personal Wallet"
        }, 
        {
            "location": "/timeline/testnet/", 
            "text": "Testnet Era\n\n\nIn January 2017, a Cardano SL test network is launched the testnet is\nrequired to get community acquainted with the cryptocurrency and to\npolish the implementation, eliminating possible flaws or instabilities.\n\n\nDuring testnet era, all the functionality, including reward mechainsm\nwill be activated and to get coin supply anyone will be able to redeem a\nprivate key from Cardano SL Testnet Faucet.\n\n\nOn January 21st 2017, testnet will be reset and users will be asked to\ndownload new, updated version of Cardano SL. This part of testnet era\ncan be thought of beta testing, resulting in the\n\nrelease\n of Cardano SL in February.\n\n\nWe encourage everyone to download Cardano SL client for your platform,\nget some coins from the faucet and invite other people to participate in\nbeta testing.", 
            "title": "Testnet Era"
        }, 
        {
            "location": "/timeline/testnet/#testnet-era", 
            "text": "In January 2017, a Cardano SL test network is launched the testnet is\nrequired to get community acquainted with the cryptocurrency and to\npolish the implementation, eliminating possible flaws or instabilities.  During testnet era, all the functionality, including reward mechainsm\nwill be activated and to get coin supply anyone will be able to redeem a\nprivate key from Cardano SL Testnet Faucet.  On January 21st 2017, testnet will be reset and users will be asked to\ndownload new, updated version of Cardano SL. This part of testnet era\ncan be thought of beta testing, resulting in the release  of Cardano SL in February.  We encourage everyone to download Cardano SL client for your platform,\nget some coins from the faucet and invite other people to participate in\nbeta testing.", 
            "title": "Testnet Era"
        }, 
        {
            "location": "/timeline/bootstrap/", 
            "text": "Bootstrap Era\n\n\nAs Cardano SL goes live in February 2017, initial ninety days it will\noperate in \u201cbootstrap mode\u201d. As people who purchased Ada redeem their\ncoins, stake will get automatically delegated to a pool of trusted nodes\nthat will maintain the network. During this time no block rewards will\nbe issued, we will maintain the network pro bono. This is required\nbecause in order for protocol to function correctly, some of\nstakeholders who jointly posses majority of stake have to be online,\nwhich, realistically, won't be the case during the first months of\nnetwork operation.\n\n\nBootstrap era will lead to the \nreward era\n when we\nissue updates to the protocol and provide big stakeholders with\nconveinent options to run their nodes in on personal servers in the\ncloud.", 
            "title": "Boostrap Era"
        }, 
        {
            "location": "/timeline/bootstrap/#bootstrap-era", 
            "text": "As Cardano SL goes live in February 2017, initial ninety days it will\noperate in \u201cbootstrap mode\u201d. As people who purchased Ada redeem their\ncoins, stake will get automatically delegated to a pool of trusted nodes\nthat will maintain the network. During this time no block rewards will\nbe issued, we will maintain the network pro bono. This is required\nbecause in order for protocol to function correctly, some of\nstakeholders who jointly posses majority of stake have to be online,\nwhich, realistically, won't be the case during the first months of\nnetwork operation.  Bootstrap era will lead to the  reward era  when we\nissue updates to the protocol and provide big stakeholders with\nconveinent options to run their nodes in on personal servers in the\ncloud.", 
            "title": "Bootstrap Era"
        }, 
        {
            "location": "/timeline/reward/", 
            "text": "Reward Era\n\n\nNinety days after the release, the reward era will start. This is part\nof Cardano SL lifetime during which the network will operate in a\ncompletely decentralized, trustless mode. We expect staking pools to\nemerge during this era, allowing stakeholders with little stake to get\nrewards as stakeholders with large stake keep their nodes online to\nmaintain the protocol in a decentralized fashion.\n\n\nThe system will receive regular software updates moving forward and\nmassive amount of new features will be released \nlater in\n2017\n.", 
            "title": "Reward Era"
        }, 
        {
            "location": "/timeline/reward/#reward-era", 
            "text": "Ninety days after the release, the reward era will start. This is part\nof Cardano SL lifetime during which the network will operate in a\ncompletely decentralized, trustless mode. We expect staking pools to\nemerge during this era, allowing stakeholders with little stake to get\nrewards as stakeholders with large stake keep their nodes online to\nmaintain the protocol in a decentralized fashion.  The system will receive regular software updates moving forward and\nmassive amount of new features will be released  later in\n2017 .", 
            "title": "Reward Era"
        }, 
        {
            "location": "/cardano/addresses/", 
            "text": "Addresses in Cardano SL\n\n\nTo send and receive value, Addresses are used in virtually any cryptocurrency.\n\n\nHow Does an Address Look Like?\n\n\nIn Cardano, we adopt Bitcoin way of encoding the address. It's called\n\u201cBase 58\u201d because it uses 58-symbol alphabet to encode data. Here is the\nalphabet we are using\n\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n. Notably,\nit avoids both non-alphanumeric characters and letters which might look\nambiguous when printed. It is therefore designed for human users who\nmanually enter the data, copying from some visual source, but also\nallows easy copy and paste because a double-click will usually select\nthe whole string. We also adopt a way to make sure that an address is\nentered correctly by appending a 32-bit Cyclic Redundancy Code checksum\n(CRC32) to the end of the part of the address which encodes public key\nor script hash. This way, full address is generated by the following\nrule, where \n is a concatenation operator:\n\ntoBase58(addr\ncrc32(addr))\n.\n\n\nAn example of a valid address is\n\n\n1EWYSJnvgnSUmp8Gi4mADvU2zkJgVAA7McgFRXiqwDBs8\n\n\n\n\nPublic Key Addresses\n\n\nAs we have discussed in the \nIntroduction\n, the\nwallets you see in the user interface are a convenient representation of\nthe fact that you own a secret key to spend money in this particular\nwallet. But how such spending is verified by the network and how can you\nreceive money from others? The answer is that along with the secret key\nwhich is used to control the value in your wallets, a public key is\ngenerated and encoded in Base58. This public component can be known by\nanybody, hence the name. Public key mostly serves two purposes:\n\n\n\n\nWhen you create a transaction, anyone with the corresponding public\n    key can verify that you indeed control secret key.\n\n\nWhen someone wants to send you the money, they use your public key\n    encoded in Base58 as the address.\n\n\n\n\nPublic key is also used to verify some protocol messages that have to be\nsigned with the secret key.\n\n\nAs we have discussed before, address is exactly the public hash key plus\nCRC32, encoded in Base58.\n\n\nPay to Script Hash\n\n\nInterestingly, Cardano SL also supports Pay to Script Hash transactions,\nmore often referred to as P2SH transactions, or just \u201cP2SH\u201d. The idea of\nP2SH is to provide a lot of flexibility to formulating complex rules for\nspending money. Instead of sending a transaction to a public key\naddress, we create a validator script into which redemption script can\nbe plugged in. To redeem funds, we evaluate validator script with\nredemption script as an argument. If validator script evaluates to\n\nsuccess\n, money is gettning sent as specified by the redeemer.\nOtherwise, nothing happens. \n\n\nTo quote Bitcoin Wiki,\n\n\n\n\nUsing P2SH, you can send bitcoins to an address that is secured in\nvarious unusual ways without knowing anything about the details of how\nthe security is set up. The recipient might need the signatures of\nseveral people to spend these bitcoins, or a password might be\nrequired, or the requirements could be completely unique.\n\n\n\n\nAdvanced Topics\n\n\nHashing\n\n\nFor a number of reasons, it is useful to have fixed-length\nrepresentation of arbitrary data, for example, when we're working with\nP2SH, we want validator scripts of arbitrary length to be hashed in a\nP2SH address of the same length that is easy to type in and operate\nwith. Also, in order to have an authenticated data structure capturing\ninformation stored on the blockchain, we have to have the same kind of\nprimitive. The requirements on such a function are manyfold:\n\n\n\n\nOn the same input data it always returns the same output string\n\n\nIt is computationally simple to calculate output for a given input\n\n\nIt is computationally complex to reverse the process\n\n\nA small change in input produces big change in output\n\n\nIt is computationally complex to find two pieces of input data that\n    produce the same output\n\n\n\n\nThe way we transform arbitrary input into output, complying with (1-5)\nis called \u201ca cryptographic hash function\u201d.\n\n\nWe are currently using two hash functions: \nSHA3\n with 256 digest and\n\nBLAKE2S\n with 224 bit digest.\n\n\nFor example, for addresses, we wrap SHA3 digest into BLAKE2s, as shown\nin the code snippet below.\n\n\ntype AddressHash = AbstractHash Blake2s_224\n\naddressHash :: Bi a =\n a -\n AddressHash b\nadressHash = AbstractHash . secondHash . firstHash\n  where\n    firstHash :: Bi a =\n a -\n Digest SHA3_256\n    firstHash = hashlazy . Bi.encode\n    secondHash :: Digest SHA3_256 -\n Digest Blake2s_224\n    secondHash = CryptoHash.hash", 
            "title": "Addresses"
        }, 
        {
            "location": "/cardano/addresses/#addresses-in-cardano-sl", 
            "text": "To send and receive value, Addresses are used in virtually any cryptocurrency.", 
            "title": "Addresses in Cardano SL"
        }, 
        {
            "location": "/cardano/addresses/#how-does-an-address-look-like", 
            "text": "In Cardano, we adopt Bitcoin way of encoding the address. It's called\n\u201cBase 58\u201d because it uses 58-symbol alphabet to encode data. Here is the\nalphabet we are using 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz . Notably,\nit avoids both non-alphanumeric characters and letters which might look\nambiguous when printed. It is therefore designed for human users who\nmanually enter the data, copying from some visual source, but also\nallows easy copy and paste because a double-click will usually select\nthe whole string. We also adopt a way to make sure that an address is\nentered correctly by appending a 32-bit Cyclic Redundancy Code checksum\n(CRC32) to the end of the part of the address which encodes public key\nor script hash. This way, full address is generated by the following\nrule, where   is a concatenation operator: toBase58(addr crc32(addr)) .  An example of a valid address is  1EWYSJnvgnSUmp8Gi4mADvU2zkJgVAA7McgFRXiqwDBs8", 
            "title": "How Does an Address Look Like?"
        }, 
        {
            "location": "/cardano/addresses/#public-key-addresses", 
            "text": "As we have discussed in the  Introduction , the\nwallets you see in the user interface are a convenient representation of\nthe fact that you own a secret key to spend money in this particular\nwallet. But how such spending is verified by the network and how can you\nreceive money from others? The answer is that along with the secret key\nwhich is used to control the value in your wallets, a public key is\ngenerated and encoded in Base58. This public component can be known by\nanybody, hence the name. Public key mostly serves two purposes:   When you create a transaction, anyone with the corresponding public\n    key can verify that you indeed control secret key.  When someone wants to send you the money, they use your public key\n    encoded in Base58 as the address.   Public key is also used to verify some protocol messages that have to be\nsigned with the secret key.  As we have discussed before, address is exactly the public hash key plus\nCRC32, encoded in Base58.", 
            "title": "Public Key Addresses"
        }, 
        {
            "location": "/cardano/addresses/#pay-to-script-hash", 
            "text": "Interestingly, Cardano SL also supports Pay to Script Hash transactions,\nmore often referred to as P2SH transactions, or just \u201cP2SH\u201d. The idea of\nP2SH is to provide a lot of flexibility to formulating complex rules for\nspending money. Instead of sending a transaction to a public key\naddress, we create a validator script into which redemption script can\nbe plugged in. To redeem funds, we evaluate validator script with\nredemption script as an argument. If validator script evaluates to success , money is gettning sent as specified by the redeemer.\nOtherwise, nothing happens.   To quote Bitcoin Wiki,   Using P2SH, you can send bitcoins to an address that is secured in\nvarious unusual ways without knowing anything about the details of how\nthe security is set up. The recipient might need the signatures of\nseveral people to spend these bitcoins, or a password might be\nrequired, or the requirements could be completely unique.", 
            "title": "Pay to Script Hash"
        }, 
        {
            "location": "/cardano/addresses/#advanced-topics", 
            "text": "", 
            "title": "Advanced Topics"
        }, 
        {
            "location": "/cardano/addresses/#hashing", 
            "text": "For a number of reasons, it is useful to have fixed-length\nrepresentation of arbitrary data, for example, when we're working with\nP2SH, we want validator scripts of arbitrary length to be hashed in a\nP2SH address of the same length that is easy to type in and operate\nwith. Also, in order to have an authenticated data structure capturing\ninformation stored on the blockchain, we have to have the same kind of\nprimitive. The requirements on such a function are manyfold:   On the same input data it always returns the same output string  It is computationally simple to calculate output for a given input  It is computationally complex to reverse the process  A small change in input produces big change in output  It is computationally complex to find two pieces of input data that\n    produce the same output   The way we transform arbitrary input into output, complying with (1-5)\nis called \u201ca cryptographic hash function\u201d.  We are currently using two hash functions:  SHA3  with 256 digest and BLAKE2S  with 224 bit digest.  For example, for addresses, we wrap SHA3 digest into BLAKE2s, as shown\nin the code snippet below.  type AddressHash = AbstractHash Blake2s_224\n\naddressHash :: Bi a =  a -  AddressHash b\nadressHash = AbstractHash . secondHash . firstHash\n  where\n    firstHash :: Bi a =  a -  Digest SHA3_256\n    firstHash = hashlazy . Bi.encode\n    secondHash :: Digest SHA3_256 -  Digest Blake2s_224\n    secondHash = CryptoHash.hash", 
            "title": "Hashing"
        }, 
        {
            "location": "/cardano/transactions/", 
            "text": "Transactions in Cardano SL\n\n\nYou can think of transactions in Cardano SL as entities that consist of\nlist of inputs and a list of outputs. Outputs of a transaction can later\nbe used as inputs for another transaction. \n\n\nEvery node (except for SPV, or lightweight nodes) in the network\nverifies transactions, so those nodes have to keep track of unspent\noutputs, this is called \u201cutxo\u201d, or \u201cUnspent Transaction Outputs\u201d. By\ntracking utxo, every node can validate that inputs in a published\ntransaction are indeed unspent outputs.\n\n\nTransactions are signed with the issuer's secret key. All of this,\nincluding selection of unspent outputs to be used as inputs is done\nautomatically and you don't have to worry about it when making a\ntransaction using Daedalus UI.\n\n\nProofs of Transaction Legitimacy\n\n\nEach transaction in Cardano is accompanied by a proof (also called a\nwitness) that this transaction is legitimate. Those proofs are stored on\nthe blockchain and anybody can see, inspect and independently verify\nthem. However, not everybody needs to do that \u2013 for instance, if you are\nan SPV node, you are trusting other nodes to do the verification, and\nthus you would rather not have those proofs sent to you with every\ntransaction, as they are useless to you. Moreover, even if you are a\nfull node, you might want to delete old proofs after some time in order\nto save space.\n\n\nThe technique of storing transactions separately from their proofs is\ncalled \u201csegregated witness\u201d (you may have heard of it being recently\nimplemented in Bitcoin). Under this scheme, transactions and proofs are\nstored in two separate places in a block, and can be processed\nindependently.", 
            "title": "Transactions"
        }, 
        {
            "location": "/cardano/transactions/#transactions-in-cardano-sl", 
            "text": "You can think of transactions in Cardano SL as entities that consist of\nlist of inputs and a list of outputs. Outputs of a transaction can later\nbe used as inputs for another transaction.   Every node (except for SPV, or lightweight nodes) in the network\nverifies transactions, so those nodes have to keep track of unspent\noutputs, this is called \u201cutxo\u201d, or \u201cUnspent Transaction Outputs\u201d. By\ntracking utxo, every node can validate that inputs in a published\ntransaction are indeed unspent outputs.  Transactions are signed with the issuer's secret key. All of this,\nincluding selection of unspent outputs to be used as inputs is done\nautomatically and you don't have to worry about it when making a\ntransaction using Daedalus UI.", 
            "title": "Transactions in Cardano SL"
        }, 
        {
            "location": "/cardano/transactions/#proofs-of-transaction-legitimacy", 
            "text": "Each transaction in Cardano is accompanied by a proof (also called a\nwitness) that this transaction is legitimate. Those proofs are stored on\nthe blockchain and anybody can see, inspect and independently verify\nthem. However, not everybody needs to do that \u2013 for instance, if you are\nan SPV node, you are trusting other nodes to do the verification, and\nthus you would rather not have those proofs sent to you with every\ntransaction, as they are useless to you. Moreover, even if you are a\nfull node, you might want to delete old proofs after some time in order\nto save space.  The technique of storing transactions separately from their proofs is\ncalled \u201csegregated witness\u201d (you may have heard of it being recently\nimplemented in Bitcoin). Under this scheme, transactions and proofs are\nstored in two separate places in a block, and can be processed\nindependently.", 
            "title": "Proofs of Transaction Legitimacy"
        }, 
        {
            "location": "/cardano/proof-of-stake/", 
            "text": "Ouroboros Proof of Stake Algorithm\n\n\nOuroboros Proof of Stake Algorithm is the most important part of\nprotocol, the way that nodes reach consensus about the state of ledger.\n\n\nOuroboros is unique as it is the first blockchain protocol based on\nproof of stake that is scientifically proved to be secure.\n\n\nWhy Proof of Stake?\n\n\nThe most important thing about picking proof of stake algorithm over\nproof of work, which is adopted by Bitcoin is the energy consumption\nconsiderations. Running Bitcoin protocol is very a tremendously\nexpensive endeavor. It is estimated, that 3.8 American Households can be\npowered for a day by the energy spent to generate one Bitcoin\ntransaction. The energy requirements for running Bitcoin protocol only\ngrow as more and more Bitcoin miners sink money into mining and\ndifficulty of the problem that their computers (mining rigs) are\ncracking increases. This is why researchers did their best to\ninvestigate alternative ways to reach consensus such as using so-called\nBFT (Byzantine Fault Tolerant) consensus algorithms and Proof of Stake\nalgorithms. First significant work on Proof of Stake was conducted by\nthe team of Nxt cryptocurrency, however their protocol had significant\nflaws and no formal verification.\n\n\nWhat is Proof of Stake?\n\n\nIn this section we explain what does \u201cProof\u201d mean and what \u201cStake\u201d\nmeans, and then we put it together, explaining what \u201cProof of Stake\u201d\nmeans.\n\n\nProof\n\n\n\u201cProof\u201d part of Proof of Stake is about having evidence that blocks of\ntransactions are legitimate.\n\n\nStake\n\n\n\u201cStake\u201d means \u201cthe relative value held by addresses on the node\u201d. When\nwe say \u201crelative value\u201d, what we mean is \u201ctake all the value held by\nwallets on a particular node and divide it by the total value in the\nsystem\u201d.\n\n\nProof of Stake\n\n\nRather miners pouring money into mining rigs running the protocol, in\norder to participate in running the protocol in Proof of Stake\nenvironment, we say that \u201cslot leaders\u201d generate blocks for the\nblockchain. Anyone can become a slot leader, if the coin selection\nalgorithm would select a coin they own. We say that this blockchain is\nself-referential that means that maintaining the blockchain relies on\nthe network participants themselves and on the network state. Nothing\nexcept for the network state and network participants being online\nmatters for the sake of Proof of Stake.\n\n\nFollow the Satoshi\n\n\nLet's elaborate a little bit on how slot leader gets selected. The\nsmallest, atomic, piece of value is called a \u201ccoin\u201d. In Bitcoin, atomic\npiece is called \u201cSatoshi\u201d, honoring the creator of Bitcoin, Satoshi\nNakamoto. Fundamentally, we can say that the ledger produces\ndistribution of coins. Follow the Satoshi is an algorithm that\nverifiably picks a coin, provided randomness. When your coin gets\nselected, you become slot leader and can listen to transactions\nannounced by others, make a block of those transactions, sign it with\nyour secret key and publish it to the network. Of course, you don't have\nto do it manually, your node will take care of everything.\n\n\nMulti Party Computation\n\n\nThe matter of fueling Follow the Satoshi with randomness is another\nproblem in itself. We're using Multi Party Computation approach when\nselect nodes provide so called \u201ccommitments\u201d and then those get\n\u201crevealed\u201d, producing a random value generated independently by\nparticipants of the network.", 
            "title": "Ouroboros Consensus Algorithm"
        }, 
        {
            "location": "/cardano/proof-of-stake/#ouroboros-proof-of-stake-algorithm", 
            "text": "Ouroboros Proof of Stake Algorithm is the most important part of\nprotocol, the way that nodes reach consensus about the state of ledger.  Ouroboros is unique as it is the first blockchain protocol based on\nproof of stake that is scientifically proved to be secure.", 
            "title": "Ouroboros Proof of Stake Algorithm"
        }, 
        {
            "location": "/cardano/proof-of-stake/#why-proof-of-stake", 
            "text": "The most important thing about picking proof of stake algorithm over\nproof of work, which is adopted by Bitcoin is the energy consumption\nconsiderations. Running Bitcoin protocol is very a tremendously\nexpensive endeavor. It is estimated, that 3.8 American Households can be\npowered for a day by the energy spent to generate one Bitcoin\ntransaction. The energy requirements for running Bitcoin protocol only\ngrow as more and more Bitcoin miners sink money into mining and\ndifficulty of the problem that their computers (mining rigs) are\ncracking increases. This is why researchers did their best to\ninvestigate alternative ways to reach consensus such as using so-called\nBFT (Byzantine Fault Tolerant) consensus algorithms and Proof of Stake\nalgorithms. First significant work on Proof of Stake was conducted by\nthe team of Nxt cryptocurrency, however their protocol had significant\nflaws and no formal verification.", 
            "title": "Why Proof of Stake?"
        }, 
        {
            "location": "/cardano/proof-of-stake/#what-is-proof-of-stake", 
            "text": "In this section we explain what does \u201cProof\u201d mean and what \u201cStake\u201d\nmeans, and then we put it together, explaining what \u201cProof of Stake\u201d\nmeans.", 
            "title": "What is Proof of Stake?"
        }, 
        {
            "location": "/cardano/proof-of-stake/#proof", 
            "text": "\u201cProof\u201d part of Proof of Stake is about having evidence that blocks of\ntransactions are legitimate.", 
            "title": "Proof"
        }, 
        {
            "location": "/cardano/proof-of-stake/#stake", 
            "text": "\u201cStake\u201d means \u201cthe relative value held by addresses on the node\u201d. When\nwe say \u201crelative value\u201d, what we mean is \u201ctake all the value held by\nwallets on a particular node and divide it by the total value in the\nsystem\u201d.", 
            "title": "Stake"
        }, 
        {
            "location": "/cardano/proof-of-stake/#proof-of-stake", 
            "text": "Rather miners pouring money into mining rigs running the protocol, in\norder to participate in running the protocol in Proof of Stake\nenvironment, we say that \u201cslot leaders\u201d generate blocks for the\nblockchain. Anyone can become a slot leader, if the coin selection\nalgorithm would select a coin they own. We say that this blockchain is\nself-referential that means that maintaining the blockchain relies on\nthe network participants themselves and on the network state. Nothing\nexcept for the network state and network participants being online\nmatters for the sake of Proof of Stake.", 
            "title": "Proof of Stake"
        }, 
        {
            "location": "/cardano/proof-of-stake/#follow-the-satoshi", 
            "text": "Let's elaborate a little bit on how slot leader gets selected. The\nsmallest, atomic, piece of value is called a \u201ccoin\u201d. In Bitcoin, atomic\npiece is called \u201cSatoshi\u201d, honoring the creator of Bitcoin, Satoshi\nNakamoto. Fundamentally, we can say that the ledger produces\ndistribution of coins. Follow the Satoshi is an algorithm that\nverifiably picks a coin, provided randomness. When your coin gets\nselected, you become slot leader and can listen to transactions\nannounced by others, make a block of those transactions, sign it with\nyour secret key and publish it to the network. Of course, you don't have\nto do it manually, your node will take care of everything.", 
            "title": "Follow the Satoshi"
        }, 
        {
            "location": "/cardano/proof-of-stake/#multi-party-computation", 
            "text": "The matter of fueling Follow the Satoshi with randomness is another\nproblem in itself. We're using Multi Party Computation approach when\nselect nodes provide so called \u201ccommitments\u201d and then those get\n\u201crevealed\u201d, producing a random value generated independently by\nparticipants of the network.", 
            "title": "Multi Party Computation"
        }, 
        {
            "location": "/cardano/plutus/introduction/", 
            "text": "Plutus is a strictly typed pure functional programming language used for\ndefining smart contracts in Cardano. The syntax is fairly Haskell-like, but\nunlike Haskell, the language is eagerly evaluated.\n\n\nDeclaring Data Types\n\n\nIn Plutus, to define a data type, we give the name of the type, then any type\nparameters, together with a list of constructor alternatives like in Haskell.\nEach constructor alternative has the types of its arguments.\n\n\nSo, for instance, the type of Peano numerals would be defined as\n\n\ndata Nat = { Zero | Suc Nat }\n\n\n\nwhereas binary trees would be defined as\n\n\ndata Tree a = { Leaf | Branch (Tree a) a (Tree a) }\n\n\n\nThe type constructor \nTree\n takes one parameter, \na\n. It's inhabited by values\nconstructed by two constructors, \nLeaf\n, which has no arguments, and \nBranch\n,\nwhich has three arguments, a left subtree of type \nTree a\n, a value of type\n\na\n, and a right subtree of type \nTree a\n.\n\n\nWe can inspect data using the \ncase\n construct, like so:\n\n\ncase t of {\n  Leaf -\n ... ;\n  Branch l x r -\n ...\n}\n\n\n\nDeclaring Values\n\n\nTo declare a new value (whether it's a function or not), we give its type, and\nthen specify its value. For instance, to define addition for natural numbers,\nwe can give a recursive definition using \ncase\n:\n\n\nadd : Nat -\n Nat -\n Nat {\n  add = \\m n -\n\n    case m of {\n      Zero -\n n ;\n      Suc m' -\n Suc (add m' n)\n    }\n}\n\n\n\nWe can also use pattern matching equations like in Haskell, which makes the\ndefinition of functions like this much more elegant:\n\n\nadd : Nat -\n Nat -\n Nat {\n  add Zero n = n ;\n  add (Suc m) n = Suc (add m n)\n}\n\n\n\nSmart Contract Computations\n\n\nPlutus has one important type built into the language specific for smart\ncontract computations: the type constructor \nComp\n, which takes one type\nparameter. The simplest way to make values is with the two computation\nconstructors \nsuccess\n, which takes a value \nM\n with type \nA\n (for any choice\nof \nA\n) and produces a computation of type \nComp A\n that represents a\nsuccessful smart contract computation that returns \nM\n. You can also build a\nvalue of type \nComp A\n with just \nfailure\n, which represents a failed\ncomputation.\n\n\nIt's also possible to chain together smart contract computations using \ndo\n\nnotation. Given a term \nM\n of the type \nComp A\n, and a term \nN\n of type\n\nComp B\n with a free variable \nx\n of type \nA\n, we can form \ndo { x \n- M ; N }\n\nwhich runs the computation \nM\n, binds its returned value to \nx\n, then runs the\ncomputation \nN\n. If the term \nM\n computes to \nfailure\n, then the failure is\npropagated by the \ndo\n construct and the whole thing computes to \nfailure\n.\n\n\nThis is most useful for building validator scripts for smart contracts. The\nstandard way this is done is by asking for a redeemer program of type \nComp A\n\nand a validator program of type \nA -\n Comp B\n, which are then composed to form\n\ndo { x \n- redeemer ; validator x }\n. The \nredeemer\n program is run, returning\nwhatever data \nvalidator\n needs, and then that data is given to \nredeemer\n,\nwhich is run.\n\n\nMore Detailed Overview\n\n\nThe other files in this directory provide a more detailed overview of the\ngrammar, types, and programs of Plutus, including the built in types and\nfunctionality, and should be read before diving into writing programs. There's\nalso a demo file, showing the implementation of a number of common functions,\nto give a good sense of the use of the language.", 
            "title": "Introduction"
        }, 
        {
            "location": "/cardano/plutus/introduction/#declaring-data-types", 
            "text": "In Plutus, to define a data type, we give the name of the type, then any type\nparameters, together with a list of constructor alternatives like in Haskell.\nEach constructor alternative has the types of its arguments.  So, for instance, the type of Peano numerals would be defined as  data Nat = { Zero | Suc Nat }  whereas binary trees would be defined as  data Tree a = { Leaf | Branch (Tree a) a (Tree a) }  The type constructor  Tree  takes one parameter,  a . It's inhabited by values\nconstructed by two constructors,  Leaf , which has no arguments, and  Branch ,\nwhich has three arguments, a left subtree of type  Tree a , a value of type a , and a right subtree of type  Tree a .  We can inspect data using the  case  construct, like so:  case t of {\n  Leaf -  ... ;\n  Branch l x r -  ...\n}", 
            "title": "Declaring Data Types"
        }, 
        {
            "location": "/cardano/plutus/introduction/#declaring-values", 
            "text": "To declare a new value (whether it's a function or not), we give its type, and\nthen specify its value. For instance, to define addition for natural numbers,\nwe can give a recursive definition using  case :  add : Nat -  Nat -  Nat {\n  add = \\m n - \n    case m of {\n      Zero -  n ;\n      Suc m' -  Suc (add m' n)\n    }\n}  We can also use pattern matching equations like in Haskell, which makes the\ndefinition of functions like this much more elegant:  add : Nat -  Nat -  Nat {\n  add Zero n = n ;\n  add (Suc m) n = Suc (add m n)\n}", 
            "title": "Declaring Values"
        }, 
        {
            "location": "/cardano/plutus/introduction/#smart-contract-computations", 
            "text": "Plutus has one important type built into the language specific for smart\ncontract computations: the type constructor  Comp , which takes one type\nparameter. The simplest way to make values is with the two computation\nconstructors  success , which takes a value  M  with type  A  (for any choice\nof  A ) and produces a computation of type  Comp A  that represents a\nsuccessful smart contract computation that returns  M . You can also build a\nvalue of type  Comp A  with just  failure , which represents a failed\ncomputation.  It's also possible to chain together smart contract computations using  do \nnotation. Given a term  M  of the type  Comp A , and a term  N  of type Comp B  with a free variable  x  of type  A , we can form  do { x  - M ; N } \nwhich runs the computation  M , binds its returned value to  x , then runs the\ncomputation  N . If the term  M  computes to  failure , then the failure is\npropagated by the  do  construct and the whole thing computes to  failure .  This is most useful for building validator scripts for smart contracts. The\nstandard way this is done is by asking for a redeemer program of type  Comp A \nand a validator program of type  A -  Comp B , which are then composed to form do { x  - redeemer ; validator x } . The  redeemer  program is run, returning\nwhatever data  validator  needs, and then that data is given to  redeemer ,\nwhich is run.", 
            "title": "Smart Contract Computations"
        }, 
        {
            "location": "/cardano/plutus/introduction/#more-detailed-overview", 
            "text": "The other files in this directory provide a more detailed overview of the\ngrammar, types, and programs of Plutus, including the built in types and\nfunctionality, and should be read before diving into writing programs. There's\nalso a demo file, showing the implementation of a number of common functions,\nto give a good sense of the use of the language.", 
            "title": "More Detailed Overview"
        }, 
        {
            "location": "/cardano/plutus/types/", 
            "text": "This document contains a reference for the types of the Plutus language. It uses\nsome informal type theory, which hopefully is understandable to everyone reading\nthis document.\n\n\nPlutus comes with a handful of built in types (ints, floats, bytestrings),\nand a single built in type operator (functions). Other types are defined by the\nauthors of programs. We'll discuss each of these in turn.\n\n\nInts, Floats, and Byte Strings\n\n\nInt\n, \nFloat\n, and \nByteString\n are primitive types, with constructor forms\ngiven by the various constants specified by the following grammar.\n\n\nint\n ::= \"-\"? \ndigit\n+\n\nfloat\n ::= \"-\"? \ndigit\n+ \nfractExponent\n\n\ndigit\n = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n\nfractExponent\n ::= \nfraction\n \nexponent\n? | \nexponent\n\n\nfraction\n ::= \".\" \ndigit\n+\n\nexponent\n ::= (\"e\" | \"E\") (\"-\" | \"+\") \ndigit\n+\n\n\nbytestring\n ::= \"#\" \nbyte\n*\n\nbyte\n ::= \nnybble\n \nnybble\n\n\nnybble\n ::= \ndigit\n\n           | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\n           | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n\n\n\nThere are no true eliminator forms for these types, but there are a number of\nbuilt in operations which can be applied to these types. We write the signatures\nof built ins as follows: \nf : (A,B) \u21c0 C\n indicates that built in name \nf\n can be\napplied to an \nA\n and a \nB\n to produce a \nC\n. The built ins for these primitive\ntypes are as follows, with implementations in terms of Haskell functions:\n\n\naddInt : (Int,Int) \u21c0 Int\n  implemented as `(+) :: Int -\n Int -\n Int`\n\nsubtractInt : (Int,Int) \u21c0 Int\n  implemented as `(-) :: Int -\n Int -\n Int`\n\nmultiplyInt : (Int,Int) \u21c0 Int\n  implemented as `(*) :: Int -\n Int -\n Int`\n\ndivideInt : (Int,Int) \u21c0 Int\n  implemented as `div :: Int -\n Int -\n Int`\n\nremainderInt : (Int,Int) \u21c0 Int\n  implemented as `(%) :: Int -\n Int -\n Int`\n\nlessThanInt : (Int,Int) \u21c0 Bool\n  implemented as `(\n) :: Int -\n Int -\n Bool`\n\nequalsInt : (Int,Int) \u21c0 Bool\n  implemented as `(==) :: Int -\n Int -\n Bool`\n\nintToFloat : (Int) \u21c0 Float\n  implemented as `fromInteger . toInteger :: Int -\n Float`\n\nintToByteString : (Int) \u21c0 ByteString\n  implemented as `encode :: Int -\n ByteString`\n\naddFloat : (Float,Float) \u21c0 Float\n  implemented as `(+) :: Float -\n Float -\n Float`\n\nsubtractFloat : (Float,Float) \u21c0 Float\n  implemented as `(-) :: Float -\n Float -\n Float`\n\nmultiplyFloat : (Float,Float) \u21c0 Float\n  implemented as `(*) :: Float -\n Float -\n Float`\n\ndivideFloat : (Float,Float) \u21c0 Float\n  implemented as `(/) :: Float -\n Float -\n Float`\n\nlessThanFloat : (Float,Float) \u21c0 Bool\n  implemented as `(\n) :: Float -\n Float -\n Bool`\n\nequalsFloat : (Float,Float) \u21c0 Bool\n  implemented as `(==) :: Float -\n Float -\n Bool`\n\nceiling : (Float) \u21c0 Float\n  implemented as `ceiling:: Float -\n Float`\n\nfloor : (Float) \u21c0 Float\n  implemented as `floor :: Float -\n Float`\n\nround : (Float) \u21c0 Float\n  implemented as `round :: Float -\n Float`\n\nconcatenate : (ByteString,ByteString) \u21c0 ByteString\n  implemented via `concat :: [ByteString] -\n ByteString`\n\ndrop : (Int,ByteString) \u21c0 ByteString\n  implemented via `drop :: Integer -\n ByteString -\n ByteString`\n\ntake : (Int,ByteString) \u21c0 ByteString\n  implemented via `take :: Integer -\n ByteString -\n ByteString`\n\nsha2_256 : (ByteString) \u21c0 ByteString\n  implemented via `hash : [Char8] -\n Digest SHA256`\n\nsha3_256 : (ByteString) \u21c0 ByteString\n  implemented via `hash : [Char8] -\n Digest SHA3_256`\n\nequalsByteString : (ByteString,ByteString) \u21c0 Bool\n  implemented as `(==) :: ByteString -\n ByteString -\n Bool`\n\n\n\nThe use of these built in functions is by prefixing the name with \n!\n and fully\napplying them to arguments. E.g., adding 2 and 3 would be \n!addInt 2 3\n.\n\n\nFunction Types\n\n\nGiven any types \nA\n and \nB\n, there is a function type \nA -\n B\n. To get a term\nof this type, we can use the lambda introduction form as follows: if \nM\n has\ntype \nB\n and has a free variable \nx\n that has type \nA\n, then \n\\x -\n M\n has type\n\nA -\n B\n. We can use a term with a function type as follows: if \nM\n has type\n\nA -\n B\n and \nN\n has type \nA\n, then \nM N\n has type \nB\n. The computation for\nfunctions is standard beta reduction: \n(\\x -\n M) N\n reduces to \n[N/x]M\n, i.e.\nto \nM\n with \nN\n substituted for \nx\n. Computation in Plutus is performed eagerly,\nand so \nN\n is evaluated before substitution is performed.\n\n\nUser Declared Types\n\n\nWhen a user declares a new data type, for example\n\n\ndata Foo a = { Bar | Baz a }\n\n\n\nthis defines a new type constructor, in this case \nFoo\n, which has the following\ninference rule associated with it: given any type \nA\n, \nFoo A\n is also a type.\n\n\nIt also comes with inference rules for the constructors, as follows: \nBar\n has\ntype \nFoo A\n, for any choice of \nA\n; and if \nM\n has type \nA\n, then \nBaz M\n has\ntype \nFoo A\n.\n\n\nThe eliminator form for user declared types is the case construct, which is used\nfor all such types. Case analysis is like in Haskell, so for example we could\nwrite\n\n\ncase foo of { Bar -\n 0 | Baz x -\n x }\n\n\n\nto analyze an element of type \nFoo Int\n, computing an \nInt\n. There is a minor\ndifference from Haskell, however, in that we can analyze multiple terms at the\nsame time, by separating them (and their corresponding patterns) with \n|\n:\n\n\ncase foo0 | foo1 of { Bar | Bar -\n 0 ; Baz x | Baz y -\n !addInt x y }\n\n\n\nCase analysis is not required to be total, that is to say, there may be missing\npatterns. Any failed match causes the entire program to fail to run, and will\ncause a transaction to be considered invalid.\n\n\nInt\n, \nFloat\n, and \nByteString\n literals can be patterns as well, so we can,\nfor example, define the factorial function using case like so:\n\n\nfacInt : Int -\n Int {\n  facInt n = case n of {\n    0 -\n 1 ;\n    _ -\n !multiplyInt n (!subtractInt n 1)\n  }\n}", 
            "title": "Types"
        }, 
        {
            "location": "/cardano/plutus/types/#ints-floats-and-byte-strings", 
            "text": "Int ,  Float , and  ByteString  are primitive types, with constructor forms\ngiven by the various constants specified by the following grammar.  int  ::= \"-\"?  digit + float  ::= \"-\"?  digit +  fractExponent  digit  = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" fractExponent  ::=  fraction   exponent ? |  exponent  fraction  ::= \".\"  digit + exponent  ::= (\"e\" | \"E\") (\"-\" | \"+\")  digit + bytestring  ::= \"#\"  byte * byte  ::=  nybble   nybble  nybble  ::=  digit \n           | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\n           | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"  There are no true eliminator forms for these types, but there are a number of\nbuilt in operations which can be applied to these types. We write the signatures\nof built ins as follows:  f : (A,B) \u21c0 C  indicates that built in name  f  can be\napplied to an  A  and a  B  to produce a  C . The built ins for these primitive\ntypes are as follows, with implementations in terms of Haskell functions:  addInt : (Int,Int) \u21c0 Int\n  implemented as `(+) :: Int -  Int -  Int`\n\nsubtractInt : (Int,Int) \u21c0 Int\n  implemented as `(-) :: Int -  Int -  Int`\n\nmultiplyInt : (Int,Int) \u21c0 Int\n  implemented as `(*) :: Int -  Int -  Int`\n\ndivideInt : (Int,Int) \u21c0 Int\n  implemented as `div :: Int -  Int -  Int`\n\nremainderInt : (Int,Int) \u21c0 Int\n  implemented as `(%) :: Int -  Int -  Int`\n\nlessThanInt : (Int,Int) \u21c0 Bool\n  implemented as `( ) :: Int -  Int -  Bool`\n\nequalsInt : (Int,Int) \u21c0 Bool\n  implemented as `(==) :: Int -  Int -  Bool`\n\nintToFloat : (Int) \u21c0 Float\n  implemented as `fromInteger . toInteger :: Int -  Float`\n\nintToByteString : (Int) \u21c0 ByteString\n  implemented as `encode :: Int -  ByteString`\n\naddFloat : (Float,Float) \u21c0 Float\n  implemented as `(+) :: Float -  Float -  Float`\n\nsubtractFloat : (Float,Float) \u21c0 Float\n  implemented as `(-) :: Float -  Float -  Float`\n\nmultiplyFloat : (Float,Float) \u21c0 Float\n  implemented as `(*) :: Float -  Float -  Float`\n\ndivideFloat : (Float,Float) \u21c0 Float\n  implemented as `(/) :: Float -  Float -  Float`\n\nlessThanFloat : (Float,Float) \u21c0 Bool\n  implemented as `( ) :: Float -  Float -  Bool`\n\nequalsFloat : (Float,Float) \u21c0 Bool\n  implemented as `(==) :: Float -  Float -  Bool`\n\nceiling : (Float) \u21c0 Float\n  implemented as `ceiling:: Float -  Float`\n\nfloor : (Float) \u21c0 Float\n  implemented as `floor :: Float -  Float`\n\nround : (Float) \u21c0 Float\n  implemented as `round :: Float -  Float`\n\nconcatenate : (ByteString,ByteString) \u21c0 ByteString\n  implemented via `concat :: [ByteString] -  ByteString`\n\ndrop : (Int,ByteString) \u21c0 ByteString\n  implemented via `drop :: Integer -  ByteString -  ByteString`\n\ntake : (Int,ByteString) \u21c0 ByteString\n  implemented via `take :: Integer -  ByteString -  ByteString`\n\nsha2_256 : (ByteString) \u21c0 ByteString\n  implemented via `hash : [Char8] -  Digest SHA256`\n\nsha3_256 : (ByteString) \u21c0 ByteString\n  implemented via `hash : [Char8] -  Digest SHA3_256`\n\nequalsByteString : (ByteString,ByteString) \u21c0 Bool\n  implemented as `(==) :: ByteString -  ByteString -  Bool`  The use of these built in functions is by prefixing the name with  !  and fully\napplying them to arguments. E.g., adding 2 and 3 would be  !addInt 2 3 .", 
            "title": "Ints, Floats, and Byte Strings"
        }, 
        {
            "location": "/cardano/plutus/types/#function-types", 
            "text": "Given any types  A  and  B , there is a function type  A -  B . To get a term\nof this type, we can use the lambda introduction form as follows: if  M  has\ntype  B  and has a free variable  x  that has type  A , then  \\x -  M  has type A -  B . We can use a term with a function type as follows: if  M  has type A -  B  and  N  has type  A , then  M N  has type  B . The computation for\nfunctions is standard beta reduction:  (\\x -  M) N  reduces to  [N/x]M , i.e.\nto  M  with  N  substituted for  x . Computation in Plutus is performed eagerly,\nand so  N  is evaluated before substitution is performed.", 
            "title": "Function Types"
        }, 
        {
            "location": "/cardano/plutus/types/#user-declared-types", 
            "text": "When a user declares a new data type, for example  data Foo a = { Bar | Baz a }  this defines a new type constructor, in this case  Foo , which has the following\ninference rule associated with it: given any type  A ,  Foo A  is also a type.  It also comes with inference rules for the constructors, as follows:  Bar  has\ntype  Foo A , for any choice of  A ; and if  M  has type  A , then  Baz M  has\ntype  Foo A .  The eliminator form for user declared types is the case construct, which is used\nfor all such types. Case analysis is like in Haskell, so for example we could\nwrite  case foo of { Bar -  0 | Baz x -  x }  to analyze an element of type  Foo Int , computing an  Int . There is a minor\ndifference from Haskell, however, in that we can analyze multiple terms at the\nsame time, by separating them (and their corresponding patterns) with  | :  case foo0 | foo1 of { Bar | Bar -  0 ; Baz x | Baz y -  !addInt x y }  Case analysis is not required to be total, that is to say, there may be missing\npatterns. Any failed match causes the entire program to fail to run, and will\ncause a transaction to be considered invalid.  Int ,  Float , and  ByteString  literals can be patterns as well, so we can,\nfor example, define the factorial function using case like so:  facInt : Int -  Int {\n  facInt n = case n of {\n    0 -  1 ;\n    _ -  !multiplyInt n (!subtractInt n 1)\n  }\n}", 
            "title": "User Declared Types"
        }, 
        {
            "location": "/cardano/plutus/examples/", 
            "text": "Here we'll take a look at some of the common examples of programs to give you a\nbetter feel for how the Plutus language works. We'll implement Peano numerals,\ncons lists, and binary trees, together with some common functions relating them.\n\n\nTo start, let's define Peano numerals:\n\n\ndata Nat = { Zero | Suc Nat }\n\n\n\nThe naturals support a variety of functions, of course, such as addition,\nmultiplication, factorial, and fibonacci, which are typical example programs.\n\n\nadd : Nat -\n Nat -\n Nat {\n  add Zero n = n ;\n  add (Suc m) n = Suc (add m n)\n}\n\nmul : Nat -\n Nat -\n Nat {\n  mul Zero _ = Zero ;\n  mul (Suc m) n = add (mul m n) n\n}\n\nfac : Nat -\n Nat {\n  fac Zero = Suc Zero ;\n  fac (Suc n) = mul (Suc n) (fac n)\n}\n\nfib : Nat -\n Nat {\n  fib Zero = Suc Zero ;\n  fib (Suc Zero) = Suc Zero ;\n  fib (Suc (Suc n)) = add (fib n) (fib (Suc n))\n}\n\n\n\nCons lists are also a familiar type:\n\n\ndata List a = { Nil | Cons a (List a) }\n\n\n\nThis demonstrates the use of parametric types, where he, \nList a\n has a type\nparameter \na\n for the type of elements. So, for example, \nList Nat\n is the type\nof lists of Peano numerals.\n\n\nLists support a variety of functions, such as \nlength\n, \nappend\n, and \nmap\n:\n\n\nlength : forall a. List a -\n Nat {\n  length Nil = Zero ;\n  length (Cons _ xs) = Suc (length xs)\n}\n\nappend : forall a. List a -\n List a -\n List a {\n  append Nil ys = ys ;\n  append (Cons x xs) ys = Cons x (append xs ys)\n}\n\nmap : forall a b. (a -\n b) -\n List a -\n List b {\n  map _ Nil = Nil ;\n  map f (Cons x xs) = Cons (f x) (map f xs)\n}\n\n\n\nHere we can see the use of polymorphism in Plutus. These functions work for any\nlist, regardless of the element type, so we can abstract over the element type\nby using \nforall\n. So for instance, the type of \nlength\n says that for any\nchoice of \na\n, we have a function of type \nList a -\n Nat\n.\n\n\nIt's important to note that in Plutus, this polymorphism exists only for the\ndeclaration of values. Any time you use a polymorphically-declared value, the\nchoice of the type variable must be fixed by the use site. You can't treat these\ndeclarations as giving polymorphic values in general, as in System-F. Rather,\na polymorphic type in a declaration is an abbreviation for an infinite family of\nidentical definitions that differ only in the choice of that type variable. For\nexample, we could define multiple \nlength\n functions like so:\n\n\nlengthNat : List Nat -\n Nat {\n  lengthNat Nil = Zero ;\n  lengthNat (Cons _ xs) = Suc (lengthNat xs)\n}\n\nlengthBool : List Bool -\n Nat {\n  lengtBool Nil = Zero ;\n  lengthBool (Cons _ xs) = Suc (lengthBool xs)\n}\n\nlengthListNat : List (List Nat) -\n Nat {\n  lengthListNat Nil = Zero ;\n  lengthListNat (Cons _ xs) = Suc (lengthListNat xs)\n}\n\n\n\nAnd they're all identical except the name and the choice for \na\n. This is of\ncourse redundant, so we can use the polymorphic declaration given above. But,\nthis declaration does not give us a value \nlength\n with the type\n\nforall a. List a -\n Nat\n. Instead, it gives us that entire infinite family of\ndeclarations, but with a convenient abbreviation syntax. This is why the use of\nsuch polymorphic declarations requires the choice of the type variables to be\nfixed at the use site.\n\n\nAnother common type is the type of binary trees with data in the branches:\n\n\ndata Tree a = { Leaf | Branch a (Tree a) (Tree a) }\n\n\n\nSuch trees support functions such as \ncount\n, \ntraversal\n, and \nreverse\n:\n\n\ncount : forall a. Tree a -\n Nat {\n  count Leaf = Zero ;\n  count (Branch _ l r) = Suc (add (count l) (count r))\n}\n\ntraversal : forall a. Tree a -\n List a {\n  traversal Leaf = Nil ;\n  traversal (Branch x l r) = Cons x (append (traversal l) (traversal r))\n}\n\nreverse : forall a. Tree a -\n Tree a {\n  reverse Leaf = Leaf ;\n  reverse (Branch x l r) = Branch x (reverse r) (reverse l)\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/for-contributors/building-from-source/", 
            "text": "Building Cardano SL and Daedalus from Source\n\n\nCardano SL consists of a collection of binaries that constitutes\nbackend, a PureScript API for the Electron-based wallet and the\nElectron-based wallet called \u201cDaedalus\u201d. You can read more about design\nand architecture of Cardano SL in the \nImplementation\nGuide\n.\n\n\nCardano SL and Daedalus Bridge\n\n\nSource code for both Cardano SL and Daedalus Bridge can be obtained\n(here)[https://github.com/input-output-hk/pos-haskell-prototype]\n\n\nWe strongly suggest using \nNix package\nmanager\n to get the right\ndependencies for building Cardano SL. It will fetch the correct\n\nopenssl\n version, but won't override the system-installed version. Same\ngoes for dependencies such as \nrocksdb\n, with which many developers\nreport having problems. The rest of documentation assumes that the reader\nhas Nix package manager installed on their machine.\n\n\nTo build the project, first clone the source base and navigate to the root\ndirectory of it:\n\n\ngit clone https://github.com/input-output-hk/pos-haskell-prototype.git\ncd pos-haskell-prototype\n\n\n\n\nThen enter \nnix-shell\n and, if it's the first project in Haskell\nlanguage on the machine, run \nstack setup\n.\n\n\nTue Jan 10 sweater@chill ~/github/pos-haskell-prototype (master) \n\u03bb nix-shell\n[nix-shell:~/github/pos-haskell-prototype]$ stack setup\n* snip *\n\n\n\n\nAfter the relevant Haskell compiler version is obtained, let's enable\nNix for all \nstack\n builds. To do so, make sure that\n\n~/.stack/config.yaml\n has the following option:\n\n\nnix:\n  enable: true\n\n\n\n\nNow in order to build Cardano SL with wallet capabilities, run the\nfollowing command:\n\n\n[nix-shell:~/github/pos-haskell-prototype]\n$ stack build --flag cardano-sl:with-wallet --flag cardano-sl:with-web\n\n\n\n\nHere is the \nasciinema\ncast\n of the project building.\n\n\nIt is suggested having at least 8GB of RAM and some swap space for the build\nprocess. As the project is fairly large and GHC parallelizes builds very\neffectively, memory and CPU consumption during the build process is\ndemanding.\n\n\nAfter the project is built, the built binaries can be launched\nusing the \nstack exec\n command. Let's discuss important binaries briefly\nbefore proceeding to next steps.\n\n\ncardano-node\n\n\nBinary \ncardano-node\n is the most important binary of the system. It\nlaunches nodes. In order to attach to a network, Hardened Kadmelia DHT\npeer information has to be supplied. Peer discovery will follow if\ninitial DHT peer is available. The syntax for communicating initial\nDHT peer is the following: \n--peer HOST:PORT/HOST_ID\n, for example\n\ndiscover.memorici.de:21989/MHdtsP-oPf7UWly7QuXnLK5RDB8=\n.\n\n\nBefore providing an example of running the node, the trickiest command\nline arguments are noted.\n\n\nWhen a testnet is bootstrapped, stake is distributed across several\naddresses in the genesis block. The distributions that are supported\nare flat distribution and Bitcoin distribution. Spending and VSS keys\nare generated for genesis block. If a node has access to a genesis key\nmapping, the index of the secret key in this mapping can be provided\nusing \n--vss-genesis N\n and \n--spending-genesis N\n, where \nN\n is index\nin this mapping.\n\n\nExample of a local invoaction connecting to HostID\n\nMHdtsP-oPf7UWly007QuXnLK5RD=\n:\n\n\nstack exec -- cardano-node \\\n  --port 3002 \\\n  --db-path run/node-db2 \\\n  --vss-genesis 2 --spending-genesis 2 \\\n  --peer 127.0.0.1:3000/MHdtsP-oPf7UWly007QuXnLK5RD= \\\n  --json-log=logs/2017-01-10_035413/node2.json \\\n  --logs-prefix logs/2017-01-10_035413 \\\n  --log-config logs/2017-01-10_035413/conf/node2.log.yaml \\\n  --flat-distr \n(3, 100000)\n\n\n\n\n\ncardano-smart-generator\n\n\nA tool which tests if transactions are accordingly sent by a node in\na network; a stress-test can be invocated by \ncardano-smart-generator\n.\nThis tool is designed to provide reasonable and reliable measurements of\ntransactions per second (or TPS).\n\n\nIt works in few rounds, each split in few phases.\n\n\nAt start, the initial transaction is submited. This transaction uses unspent\noutput from the genesis address, index of which is supplied as \n--index\n\nargument and creates \n(k + P) * slotDuration * maxTPS\n outputs, which\nwould be used for further transactions. \nk\n (block depth to treat\ntransaction as stable) and \nP\n (approximate amount of slots needed for a\ntransaction to be successfully published in a block) are parameters\nhere. During our benchmarks we were using \nk=6\n and \nP=2\n with hundred\nnodes.\n\n\nEach round of \ncardano-smart-generator\n tests that the system is capable of\nhandling a concrete TPS value. It goes from value provided by \n--tps\n\nCLI argument and adjusts it every step by \n--tps-step\n value. Both can\nbe fractional (double precision floats). The process will continue for\nat most \n--round-number\n (\nN\n) rounds.\n\n\nThis way, \nmaxTps = initTps + tpsStep * N\n.\n\n\nAll further transactions are \n(in, 1, A)\n, where \n\n\n\n\nA\n is the owner of \nin\n;\n\n\n1 is the amount of coins transferred;\n\n\nin\n is the output of previous transaction;  \n\n\n\n\nEach subsequent transaction is being sent only if the parent is included\ninto block of depth \nk\n (i.e stable). This way there's no possibility\nof producing more transactions than a node can include into blocks.\n\n\nEach round is split to \n(R + 2)\n phases. On each phase transactions are\nsent with current TPS rate. On the first phase no measurements are taken.gq\nOn the last phase no new transactions get emmitted, only confirmations\nfor sent ones being collected.\n\n\nEach phase takes \n(k + P) * slotDuration\n seconds, where \nP\n is\napproximate amount of slots needed for a successful transaction to be\npublished in block.\n\n\nTransactions are sent in a few threads. Each thread uses its own\ntransaction pool derived from its own index in genesis block.\n\n\nHere is an example of invocation of \ncardano-smart-generator\n sending\ntransactions from node number zero:\n\n\nstack exec -- cardano-smart-generator \\\n  --json-log=txgen.json \\\n  --index 0 \\\n  --round-period-rate 60 \\\n  --round-number 10 \\\n  --tps 50 \\\n  --propagate-threshold 4 \\\n  --tps-sleep 20 \\\n  --init-money 100000 \\\n  --peer 127.0.0.1:3000/MHdtsP-oPf7UWly007QuXnLK5RD=\n\n\n\n\nThe purpose of the most important binaries and basic\noperations with said binaries is clarified, let's proceed with building\nthe wallet. On the Haskell side of things, just two matters have to be\naddressed \u2014\n\n\n\n\nGenerate types for \ndaedalus-bridge\n\n\nBuild Daedalus Bridge\n\n\n\n\nGenerating Types for Daedalus Bridge\n\n\nTo generate types, run\n\n\nstack exec -- cardano-wallet-hs2purs\n\n\n\n\nA warning message will be printed that is safe to ignore. Once the types\nare generated, proceed to the next step.\n\n\nBuilding Daedalus Bridge\n\n\nTo build Daedalus Bridge, some JavaScript heavy-lifting must be done.\nCurrently Nix expressions don't install Node.js and NPM, so\nthose have to be installed manually. To do that, consult the repositories\nof the package manager of according OS or download binaries from \nthe\nnet\n you also will need the following\nnpm packages: \nbower\n, \npulp\n, \npurescript\n. Those can be installed with\n\n\nnpm install -g bower pulp purescript\n\n\n\n\nTo build Daedalus Bridge with npm installed, run the following commands:\n\n\ncd daedalus\nnpm install\n\n\n\n\nRunning \nnpm install\n will register \ndaedalus-bridge\n in local npm\npackage repository. This way, at any time, \ndaedalus-bridge\n\ndependency can be satisfied in any project that depends on it by\nmanually running \nnpm link daedalus-bridge\n.\n\n\nBuilding Daedalus\n\n\nIf the instructions of building Cardano SL and the Bridge have been followed,\nbuilding Daedalus wallet is as simple as cloning Daedalus' repository:\n\n\ngit clone https://github.com/input-output-hk/daedalus.git\ncd daedalus\n\n\n\n\nThen execute the following command:\n\n\nnpm install\n\n\n\n\nNow to run the wallet connected to the Cardano SL in dev-mode, call\n\n\nnpm run dev", 
            "title": "Building From Source"
        }, 
        {
            "location": "/for-contributors/building-from-source/#building-cardano-sl-and-daedalus-from-source", 
            "text": "Cardano SL consists of a collection of binaries that constitutes\nbackend, a PureScript API for the Electron-based wallet and the\nElectron-based wallet called \u201cDaedalus\u201d. You can read more about design\nand architecture of Cardano SL in the  Implementation\nGuide .", 
            "title": "Building Cardano SL and Daedalus from Source"
        }, 
        {
            "location": "/for-contributors/building-from-source/#cardano-sl-and-daedalus-bridge", 
            "text": "Source code for both Cardano SL and Daedalus Bridge can be obtained\n(here)[https://github.com/input-output-hk/pos-haskell-prototype]  We strongly suggest using  Nix package\nmanager  to get the right\ndependencies for building Cardano SL. It will fetch the correct openssl  version, but won't override the system-installed version. Same\ngoes for dependencies such as  rocksdb , with which many developers\nreport having problems. The rest of documentation assumes that the reader\nhas Nix package manager installed on their machine.  To build the project, first clone the source base and navigate to the root\ndirectory of it:  git clone https://github.com/input-output-hk/pos-haskell-prototype.git\ncd pos-haskell-prototype  Then enter  nix-shell  and, if it's the first project in Haskell\nlanguage on the machine, run  stack setup .  Tue Jan 10 sweater@chill ~/github/pos-haskell-prototype (master) \n\u03bb nix-shell\n[nix-shell:~/github/pos-haskell-prototype]$ stack setup\n* snip *  After the relevant Haskell compiler version is obtained, let's enable\nNix for all  stack  builds. To do so, make sure that ~/.stack/config.yaml  has the following option:  nix:\n  enable: true  Now in order to build Cardano SL with wallet capabilities, run the\nfollowing command:  [nix-shell:~/github/pos-haskell-prototype]\n$ stack build --flag cardano-sl:with-wallet --flag cardano-sl:with-web  Here is the  asciinema\ncast  of the project building.  It is suggested having at least 8GB of RAM and some swap space for the build\nprocess. As the project is fairly large and GHC parallelizes builds very\neffectively, memory and CPU consumption during the build process is\ndemanding.  After the project is built, the built binaries can be launched\nusing the  stack exec  command. Let's discuss important binaries briefly\nbefore proceeding to next steps.", 
            "title": "Cardano SL and Daedalus Bridge"
        }, 
        {
            "location": "/for-contributors/building-from-source/#cardano-node", 
            "text": "Binary  cardano-node  is the most important binary of the system. It\nlaunches nodes. In order to attach to a network, Hardened Kadmelia DHT\npeer information has to be supplied. Peer discovery will follow if\ninitial DHT peer is available. The syntax for communicating initial\nDHT peer is the following:  --peer HOST:PORT/HOST_ID , for example discover.memorici.de:21989/MHdtsP-oPf7UWly7QuXnLK5RDB8= .  Before providing an example of running the node, the trickiest command\nline arguments are noted.  When a testnet is bootstrapped, stake is distributed across several\naddresses in the genesis block. The distributions that are supported\nare flat distribution and Bitcoin distribution. Spending and VSS keys\nare generated for genesis block. If a node has access to a genesis key\nmapping, the index of the secret key in this mapping can be provided\nusing  --vss-genesis N  and  --spending-genesis N , where  N  is index\nin this mapping.  Example of a local invoaction connecting to HostID MHdtsP-oPf7UWly007QuXnLK5RD= :  stack exec -- cardano-node \\\n  --port 3002 \\\n  --db-path run/node-db2 \\\n  --vss-genesis 2 --spending-genesis 2 \\\n  --peer 127.0.0.1:3000/MHdtsP-oPf7UWly007QuXnLK5RD= \\\n  --json-log=logs/2017-01-10_035413/node2.json \\\n  --logs-prefix logs/2017-01-10_035413 \\\n  --log-config logs/2017-01-10_035413/conf/node2.log.yaml \\\n  --flat-distr  (3, 100000)", 
            "title": "cardano-node"
        }, 
        {
            "location": "/for-contributors/building-from-source/#cardano-smart-generator", 
            "text": "A tool which tests if transactions are accordingly sent by a node in\na network; a stress-test can be invocated by  cardano-smart-generator .\nThis tool is designed to provide reasonable and reliable measurements of\ntransactions per second (or TPS).  It works in few rounds, each split in few phases.  At start, the initial transaction is submited. This transaction uses unspent\noutput from the genesis address, index of which is supplied as  --index \nargument and creates  (k + P) * slotDuration * maxTPS  outputs, which\nwould be used for further transactions.  k  (block depth to treat\ntransaction as stable) and  P  (approximate amount of slots needed for a\ntransaction to be successfully published in a block) are parameters\nhere. During our benchmarks we were using  k=6  and  P=2  with hundred\nnodes.  Each round of  cardano-smart-generator  tests that the system is capable of\nhandling a concrete TPS value. It goes from value provided by  --tps \nCLI argument and adjusts it every step by  --tps-step  value. Both can\nbe fractional (double precision floats). The process will continue for\nat most  --round-number  ( N ) rounds.  This way,  maxTps = initTps + tpsStep * N .  All further transactions are  (in, 1, A) , where    A  is the owner of  in ;  1 is the amount of coins transferred;  in  is the output of previous transaction;     Each subsequent transaction is being sent only if the parent is included\ninto block of depth  k  (i.e stable). This way there's no possibility\nof producing more transactions than a node can include into blocks.  Each round is split to  (R + 2)  phases. On each phase transactions are\nsent with current TPS rate. On the first phase no measurements are taken.gq\nOn the last phase no new transactions get emmitted, only confirmations\nfor sent ones being collected.  Each phase takes  (k + P) * slotDuration  seconds, where  P  is\napproximate amount of slots needed for a successful transaction to be\npublished in block.  Transactions are sent in a few threads. Each thread uses its own\ntransaction pool derived from its own index in genesis block.  Here is an example of invocation of  cardano-smart-generator  sending\ntransactions from node number zero:  stack exec -- cardano-smart-generator \\\n  --json-log=txgen.json \\\n  --index 0 \\\n  --round-period-rate 60 \\\n  --round-number 10 \\\n  --tps 50 \\\n  --propagate-threshold 4 \\\n  --tps-sleep 20 \\\n  --init-money 100000 \\\n  --peer 127.0.0.1:3000/MHdtsP-oPf7UWly007QuXnLK5RD=  The purpose of the most important binaries and basic\noperations with said binaries is clarified, let's proceed with building\nthe wallet. On the Haskell side of things, just two matters have to be\naddressed \u2014   Generate types for  daedalus-bridge  Build Daedalus Bridge", 
            "title": "cardano-smart-generator"
        }, 
        {
            "location": "/for-contributors/building-from-source/#generating-types-for-daedalus-bridge", 
            "text": "To generate types, run  stack exec -- cardano-wallet-hs2purs  A warning message will be printed that is safe to ignore. Once the types\nare generated, proceed to the next step.", 
            "title": "Generating Types for Daedalus Bridge"
        }, 
        {
            "location": "/for-contributors/building-from-source/#building-daedalus-bridge", 
            "text": "To build Daedalus Bridge, some JavaScript heavy-lifting must be done.\nCurrently Nix expressions don't install Node.js and NPM, so\nthose have to be installed manually. To do that, consult the repositories\nof the package manager of according OS or download binaries from  the\nnet  you also will need the following\nnpm packages:  bower ,  pulp ,  purescript . Those can be installed with  npm install -g bower pulp purescript  To build Daedalus Bridge with npm installed, run the following commands:  cd daedalus\nnpm install  Running  npm install  will register  daedalus-bridge  in local npm\npackage repository. This way, at any time,  daedalus-bridge \ndependency can be satisfied in any project that depends on it by\nmanually running  npm link daedalus-bridge .", 
            "title": "Building Daedalus Bridge"
        }, 
        {
            "location": "/for-contributors/building-from-source/#building-daedalus", 
            "text": "If the instructions of building Cardano SL and the Bridge have been followed,\nbuilding Daedalus wallet is as simple as cloning Daedalus' repository:  git clone https://github.com/input-output-hk/daedalus.git\ncd daedalus  Then execute the following command:  npm install  Now to run the wallet connected to the Cardano SL in dev-mode, call  npm run dev", 
            "title": "Building Daedalus"
        }, 
        {
            "location": "/glossary/", 
            "text": "Glossary\n\n\nGlossary of terms related to Cardano SL.\n\n\nCore Concepts\n\n\nCryptocurrency\n\n\nComputer system which uses cryptographic protocols to generate a ledger.\n\n\nCardano SL\n\n\nHybrid decentralized cryptocurrency.\n\n\nLedger\n\n\nA collection of data that keeps track of value assigned to individuals.\n\n\nTransaction\n\n\nData that represents the act of transferring value.\n\n\nDecentralization\n\n\nA notion of a computer system operating through interaction of independent\nnodes. In case of maintaining a shared data collection such as ledger, a\nconsensus is required for consistency and thus reliability of data.\n\n\nConsensus Algorithm\n\n\nA way for a decentralized system to reach a consistent view on shared\ncollections of data. Cardano SL uses the \nOuroboros Consensus\nAlgorithm\n, which is an algorithm based on\nProof of Stake.\n\n\nProof of Stake\n\n\nTo generate data in a decentralized environment, election of a temporary\nauthority is required. This temporary authority will tell which data should\nbe included into the shared collection. In case of cryptocurrencies, the data\nincluded is transactions Proof of Stake approach is to say that the more value\nsomeone has, the more inclined they are to maintain the ledger. Thus, the\nprobability of a user (\nAlice\n) having right to add a group of transactions\n(called \nblock\n) to the collection of data from which the ledger can be\nderived (called \nblockchain\n) is determined by the percentage of the total\nvalue (the money Alice has is called \nstake\n, and Alice herself is\ncalled \nstakeholder\n) in the system she owns (see \nFollow the\nSatoshi\n).\n\n\nNode\n\n\nA computer that runs a computer program that participates in a decentralized\nprotocol system.\n\n\nProtocol Basics\n\n\nSlot\n\n\nA small period of time that is significantly larger than the expected\ndifference in clocks on different nodes.\n\n\nEpoch\n\n\nA bigger period of time for which we know in advance who will have the right\nto generate a block in each slot.\n\n\nFollow The Satoshi\n\n\nA mechanism whereby stakeholders are selected at random to forge a new block\nin the blockchain, with proportional chance to get elected depending on their\namount of stake in the protocol.\n\n\nLeader Selection\n\n\nA process of picking who will generate blocks in the next epoch. Leaders are\nselected with probability proportional to their stake (see\n\nProof of Stake\n, \nFollow the Satoshi\n).", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary", 
            "text": "Glossary of terms related to Cardano SL.", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#core-concepts", 
            "text": "", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/glossary/#cryptocurrency", 
            "text": "Computer system which uses cryptographic protocols to generate a ledger.", 
            "title": "Cryptocurrency"
        }, 
        {
            "location": "/glossary/#cardano-sl", 
            "text": "Hybrid decentralized cryptocurrency.", 
            "title": "Cardano SL"
        }, 
        {
            "location": "/glossary/#ledger", 
            "text": "A collection of data that keeps track of value assigned to individuals.", 
            "title": "Ledger"
        }, 
        {
            "location": "/glossary/#transaction", 
            "text": "Data that represents the act of transferring value.", 
            "title": "Transaction"
        }, 
        {
            "location": "/glossary/#decentralization", 
            "text": "A notion of a computer system operating through interaction of independent\nnodes. In case of maintaining a shared data collection such as ledger, a\nconsensus is required for consistency and thus reliability of data.", 
            "title": "Decentralization"
        }, 
        {
            "location": "/glossary/#consensus-algorithm", 
            "text": "A way for a decentralized system to reach a consistent view on shared\ncollections of data. Cardano SL uses the  Ouroboros Consensus\nAlgorithm , which is an algorithm based on\nProof of Stake.", 
            "title": "Consensus Algorithm"
        }, 
        {
            "location": "/glossary/#proof-of-stake", 
            "text": "To generate data in a decentralized environment, election of a temporary\nauthority is required. This temporary authority will tell which data should\nbe included into the shared collection. In case of cryptocurrencies, the data\nincluded is transactions Proof of Stake approach is to say that the more value\nsomeone has, the more inclined they are to maintain the ledger. Thus, the\nprobability of a user ( Alice ) having right to add a group of transactions\n(called  block ) to the collection of data from which the ledger can be\nderived (called  blockchain ) is determined by the percentage of the total\nvalue (the money Alice has is called  stake , and Alice herself is\ncalled  stakeholder ) in the system she owns (see  Follow the\nSatoshi ).", 
            "title": "Proof of Stake"
        }, 
        {
            "location": "/glossary/#node", 
            "text": "A computer that runs a computer program that participates in a decentralized\nprotocol system.", 
            "title": "Node"
        }, 
        {
            "location": "/glossary/#protocol-basics", 
            "text": "", 
            "title": "Protocol Basics"
        }, 
        {
            "location": "/glossary/#slot", 
            "text": "A small period of time that is significantly larger than the expected\ndifference in clocks on different nodes.", 
            "title": "Slot"
        }, 
        {
            "location": "/glossary/#epoch", 
            "text": "A bigger period of time for which we know in advance who will have the right\nto generate a block in each slot.", 
            "title": "Epoch"
        }, 
        {
            "location": "/glossary/#follow-the-satoshi", 
            "text": "A mechanism whereby stakeholders are selected at random to forge a new block\nin the blockchain, with proportional chance to get elected depending on their\namount of stake in the protocol.", 
            "title": "Follow The Satoshi"
        }, 
        {
            "location": "/glossary/#leader-selection", 
            "text": "A process of picking who will generate blocks in the next epoch. Leaders are\nselected with probability proportional to their stake (see Proof of Stake ,  Follow the Satoshi ).", 
            "title": "Leader Selection"
        }
    ]
}